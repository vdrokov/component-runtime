[{"lang":"en","title":"Advanced: define a custom API","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-custom-api.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Advanced: define a custom API","In this article"],"lvl1":["Extending the UI"],"text":["It is possible to extend the Component API for custom front features.","What is important here is to keep in mind you should do it only if it targets not portable components (only used by the Studio or Beam).","In term of organization it is recommanded to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI just add an annotation which can be put on @Option fields which is decorated with @Ui. All its members will be put in the metadata of the parameter. Example:"]},{"lang":"en","title":"Beam testing","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-beam.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Beam testing","In this article"],"text":["If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details."]},{"lang":"en","title":"Best practises","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-best-practices.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Best practises","In this article"],"lvl1":["Parameterized tests"],"lvl2":["JUnit 4","JUnit 5"],"text":["this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature."]},{"lang":"en","title":"Build tools","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-build-tools.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Build tools","In this article"],"lvl1":["Maven Plugin","Gradle Plugin"],"lvl2":["Dependencies","Validate","Documentation","Web","Generate inputs or outputs","Talend Component Archive"],"lvl3":["Render your documentation"],"text":["talend-component-maven-plugin intends to help you to write components validating components match best practices and also generating transparently metadata used by Talend Studio.","Here is how to use it:","Note that this plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin, it will create the TALEND-INF/dependencies.txt file with the compile and runtime dependencies to let the component use it at runtime:","The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:","By default it will be bound to process-classes phase. When executing it will do several validations which can be switched off adding the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates resource bundle are presents and contain commonly used keys (like _displayName)","true","validateModel","Ensure components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensure components are Serializable - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensure components define an @Icon and @Version.","true","validateDataStore","Ensure any @DataStore defines a @HealthCheck.","true","validateComponent","Ensure native programming model is respected, you can disable it when using another programming model like in beam case.","true","validateActions","Validate actions signatures for the ones not tolerating dynamic binding (@HealthCheck, @DynamicValues, …). It is recommanded to keep it true.","true","validateFamily","Validate the family, i.e. the package containing the @Components has also a @Icon.","true","validateDocumentation","Ensure all 1. components and 2. @Option properties have a documentation using @Documentation","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and @Documentation you can put on options and the component itself.","Name","Description","Default","level","Which level are the root title","2 which means ==","output","Where to store the output, it is NOT recommended to change it","${classes}/TALEND-INF/documentation.adoc","formats","A map of the renderings to do, keys are the format (pdf or html) and values the output paths","-","attributes","A map of asciidoctor attributes when formats is set","-","templateDir / templateEngine","Template configuration for the rendering","-","title","Document title","${project.name}","attachDocumentations","Should the documentations (.adoc, and formats keys) should be attached to the project (and deployed)","true","if you use the extension you can add the property talend.documentation.htmlAndPdf and set it to true in your project to automatically get a html and PDF rendering of the documentation.","To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):","Will generate in target/classes/TALEND-INF/documentation.adoc the components documentation.","Will render the documenation as an html file in target/documentation/documentation.html.","ensure to execute it after the documentation generation.","If you prefer a PDF rendering you can configure the following execution in the asciidoctor plugin (note that you can configure both executions if you want both HTML and PDF rendering):","If you want to add some more content or add a title, you can include the generated document into another document using Asciidoc include directive.","A common example is:","This assumes you pass to the plugin the attribute generated_doc, this can be done this way:","This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.","You can find more customizations on Asciidoctor website.","Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don’t forget the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering, you can use the goal web of the plugin:","Then you can test your component going on localhost:8080. You need to select which component form you want to see using the treeview on the left, then on the right the form will be displayed.","The two available configurations of the plugin are serverPort which is a shortcut to change the default, 8080, port of the embedded server and serverArguments to pass Meecrowave options to the server. More on that configuration is available at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","this command reads the component jar from the local maven repository so ensure to install the artifact before using it.","The Mojo generate (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration):","For this command to work you will need to just register the plugin:","Component ARchive (.car) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested maven repository containing the component and its depenencies.","It will create a .car in your build directory which is shareable on Talend platforms.","Note that this CAR is executable and exposes the command studio-deploy which takes as parameter a Talend Studio home location. Executed it will install the dependencies into the studio and register the component in your instance. Here is a sample launch command:","gradle-talend-component intends to help you to write components validating components match best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file the SDK uses to build the component classpath. For more information on the configuration you can check out the maven properties matching the attributes.","Here is how to use it:"]},{"lang":"en","title":"Built in services","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-built-in.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Built in services","In this article"],"lvl1":["HttpClient usage"],"lvl2":["Advanced HTTP client request customization"],"text":["The framework provides some built-in services you can inject by type in components and actions out of the box.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data which don’t need to be recomputed very often. Commonly used by actions for the UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","it assumes the dependency is locally available to the execution instance which is not guaranteed yet by the framework.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration which can be used during the design.","it is not recommanded to use it for the runtime since the local configuration is generally different and the instances are distincts.","you can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","This let you define an http client in a declarative manner using an annotated interface.","See the HttpClient usage for details.","Let assume that we have a REST API defined like below, and that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","with a json playload to be created {\"id\":\"some id\", \"data\":\"some data\"}","To create an http client able to consume this REST API, we will define an interface that extends HttpClient,","The HttpClient interface lets you set the base for the http address that our client will hit.","The base is the part of the address that we will need to add to the request path to hit the api.","Every method annotated with @Request of our interface will define an http request. Also every request can have @Codec that let us encode/decode the request/response playloads.","if your payload(s) is(are) String or Void you can ignore the coder/decoder.","The interface should extends HttpClient.","In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with @Service or @Internationalized into the constructor. The i18n services can be useful to have i18n messages for errors handling for example.","This interface can be injected into our Components classes or Services to consume the defined api.","Note: by default /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases you can customize the Connection directly using @UseConfigurer on the method. It will call your custom instance of Configurer. Note that you can use some @ConfigurerOption in the method signature to pass some configurer configuration.","For instance if you have this configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:"]},{"lang":"en","title":"Component Loading","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/component-loading.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Component Loading","In this article"],"lvl1":["Packaging a plugin","Packaging an application"],"lvl2":["Dependencies","Listing needed plugins","maven-shade-plugin extensions"],"lvl3":["Create a nested maven repository with maven-shade-plugin","ContainerDependenciesTransformer","PluginTransformer"],"text":["Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts it requires to isolate plugins (components or component grouped in a single jar/plugin).","Here we have multiple options which are (high level):","flat classpath: listed for completeness but rejected by design because it doesn’t match at all this requirement.","tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes are not seen by the shared classloader nor by other plugins.","graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.","If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications and the graph classloading can be illustrated by OSGi containers.","In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage is you don’t need to define the relationship with other plugins/dependencies (it is built-in).","Here is a representation of this solution:","","The interesting part is the shared area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.","Then each plugins will be loaded in their own classloader with their dependencies.","this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.","A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt location so you just need to ensure your component defines the following plugin:","If you check your jar once built you will see that the file contains something like:","What is important to see is the scope associated to the artifacts:","the API (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (it comes with the framework)","your specific dependencies (awesome-project) is compile: it will be included as a needed dependency by the framework (note that using runtime works too).","the other dependencies will be ignored (test dependencies)","Even if a flat classpath deployment is possible, it is not recommanded because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:","This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component runtime has two ways to find an artifact:","from the file system based on a configure maven 2 repository.","from a fatjar (uber jar) with a nested maven repository under MAVEN-INF/repository.","The first option will use either - by default - ${user.home}/.m2/repository or a specific path configured when creating a ComponentManager. The nested repository option will need some configuration during the packaging to ensure the repository is well created.","To create the nested MAVEN-INF/repository repository you can use nested-maven-repository extension:","Plugin are programmatically registered in general but if you want to make some of them automatically available you need to generate a TALEND-INF/plugins.properties which will map a plugin name to coordinates found with the maven mecanism we just talked about.","Here again we can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven shade plugin:","the configuration unrelated to transformers can depend your application.","ContainerDependenciesTransformer is the one to embed a maven repository and PluginTransformer to create a file listing (one per line) a list of artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma separated list of scope to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system, test).","include: a comma separated list of artifact to include in the artifact filtering.","exclude: a comma separated list of artifact to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included, true by default.","includeProjectComponentDependencies: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).","userArtifacts: set of component artifacts to include.","to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies, you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended practise is to use userArtifacts for the components and not the project <dependencies>.","ContainerDependenciesTransformer specific configuration is the following one:","repositoryBase: base repository location (default to MAVEN-INF/repository).","ignoredPaths: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","Example: if you want to list only the plugins you use you can configure this transformer like that:"]},{"lang":"en","title":"Components Definition","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/component-definition.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Components Definition","In this article"],"lvl1":["PartitionMapper","Definition","Producer","Processor","Multiple outputs","Multiple inputs","Output","Combiners?"],"lvl2":["@Assessor","@Split","@Emitter"],"text":["Talend Component framework relies on several primitive components.","They can all use @PostConstruct and @PreDestroy to initialize/release some underlying resource at the beginning/end of the processing.","in distributed environments class' constructor will be called on cluster manager node, methods annotated with @PostConstruct and @PreDestroy annotations will be called on worker nodes. Thus, partition plan computation and pipeline task will be performed on different nodes.","","Created task consists of Jar file, containing class, which describes pipeline(flow) which should be processed in cluster.","During partition plan computation step pipeline is analyzed and split into stages. Cluster Manager node instantiates mappers/processors gets estimated data size using mappers, splits created mappers according to the estimated data size. All instances are serialized and sent to Worker nodes afterwards.","Serialized instances are received and deserialized, methods annotated with @PostConstruct annotation are called. After that, pipeline execution is started. Processor’s @BeforeGroup annotated method is called before processing first element in chunk. After processing number of records estimated as chunk size, Processor’s @AfterGroup annotated method called. Chunk size is calculated depending on environment the pipeline is processed by. After pipeline is processed, methods annotated with @PreDestroy annotation are called.","","","all framework managed methods MUST be public too. Private methods are ignored.","in term of design the framework tries to be as declarative as possible but also to stay extensible not using fixed interfaces or method signatures. This will allow to add incrementally new features of the underlying implementations.","A PartitionMapper is a component able to split itself to make the execution more efficient.","This concept is borrowed to big data world and useful only in this context (BEAM executions). Overall idea is to divide the work before executing it to try to reduce the overall execution time.","The process is the following:","Estimate the size of the data you will work on. This part is often heuristic and not very precise.","From that size the execution engine (runner for beam) will request the mapper to split itself in N mappers with a subset of the overall work.","The leaf (final) mappers will be used as a Producer (actual reader) factory.","this kind of component MUST be Serializable to be distributable.","A partition mapper requires 3 methods marked with specific annotations:","@Assessor for the evaluating method","@Split for the dividing method","@Emitter for the Producer factory","The assessor method will return the estimated size of the data related to the component (depending its configuration). It MUST return a Number and MUST not take any parameter.","Here is an example:","The split method will return a collection of partition mappers and can take optionally a @PartitionSize long value which is the requested size of the dataset per sub partition mapper.","Here is an example:","The emitter method MUST not have any parameter and MUST return a producer. It generally uses the partition mapper configuration to instantiate/configure the producer.","Here is an example:","A Producer is the component interacting with a physical source. It produces input data for the processing flow.","A producer is a very simple component which MUST have a @Producer method without any parameter and returning any data:","A Processor is a component responsible to convert an incoming data to another model.","A processor MUST have a method decorated with @ElementListener taking an incoming data and returning the processed data:","this kind of component MUST be Serializable since it is distributed.","if you don’t care much of the type of the parameter and need to access data on a \"map like\" based rule set, then you can use JsonObject as parameter type and Talend Component will just wrap the data to enable you to access it as a map. The parameter type is not enforced, i.e. if you know you will get a SuperCustomDto then you can use that as parameter type but for generic component reusable in any chain it is more than highly encouraged to use JsonObject until you have your an evaluation language based processor (which has its own way to access component). Here is an example:","A processor also supports @BeforeGroup and @AfterGroup which MUST be methods without parameters and returning void (result would be ignored). This is used by the runtime to mark a chunk of the data in a way which is estimated good for the execution flow size.","this is estimated so you don’t have any guarantee on the size of a group. You can literally have groups of size 1.","The common usage is to batch records for performance reasons:","it is a good practise to support a maxBatchSize here and potentially commit before the end of the group in case of a computed size which is way too big for your backend.","In some case you may want to split the output of a processor in two. A common example is \"main\" and \"reject\" branches where part of the incoming data are put in a specific bucket to be processed later.","This can be done using @Output. This can be used as a replacement of the returned value:","Or you can pass it a string which will represent the new branch:","Having multiple inputs is closeto the output case excep it doesn’t require a wrapper OutputEmitter:","@Input takes the input name as parameter, if not set it uses the main (default) input branch.","due to the work required to not use the default branch it is recommanded to use it when possible and not name its branches depending on the component semantic.","An Output is a Processor returning no data.","Conceptually an output is a listener of data. It perfectly matches the concept of processor. Being the last of the execution chain or returning no data will make your processor an output:","For now Talend Component doesn’t enable you to define a Combiner. It would be the symmetric part of the partition mapper and allow to aggregate results in a single one."]},{"lang":"en","title":"Components Packaging","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-packaging.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Components Packaging","In this article"],"lvl1":["Component Loading"],"lvl2":["Packaging a plugin","Packaging an application"],"lvl3":["Dependencies","Listing needed plugins","maven-shade-plugin extensions"],"text":["Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts it requires to isolate plugins (components or component grouped in a single jar/plugin).","Here we have multiple options which are (high level):","flat classpath: listed for completeness but rejected by design because it doesn’t match at all this requirement.","tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes are not seen by the shared classloader nor by other plugins.","graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.","If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications and the graph classloading can be illustrated by OSGi containers.","In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage is you don’t need to define the relationship with other plugins/dependencies (it is built-in).","Here is a representation of this solution:","","The interesting part is the shared area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.","Then each plugins will be loaded in their own classloader with their dependencies.","this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.","A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt location so you just need to ensure your component defines the following plugin:","If you check your jar once built you will see that the file contains something like:","What is important to see is the scope associated to the artifacts:","the API (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (it comes with the framework)","your specific dependencies (awesome-project) is compile: it will be included as a needed dependency by the framework (note that using runtime works too).","the other dependencies will be ignored (test dependencies)","Even if a flat classpath deployment is possible, it is not recommanded because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:","This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component runtime has two ways to find an artifact:","from the file system based on a configure maven 2 repository.","from a fatjar (uber jar) with a nested maven repository under MAVEN-INF/repository.","The first option will use either - by default - ${user.home}/.m2/repository or a specific path configured when creating a ComponentManager. The nested repository option will need some configuration during the packaging to ensure the repository is well created.","To create the nested MAVEN-INF/repository repository you can use nested-maven-repository extension:","Plugin are programmatically registered in general but if you want to make some of them automatically available you need to generate a TALEND-INF/plugins.properties which will map a plugin name to coordinates found with the maven mecanism we just talked about.","Here again we can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven shade plugin:","the configuration unrelated to transformers can depend your application.","ContainerDependenciesTransformer is the one to embed a maven repository and PluginTransformer to create a file listing (one per line) a list of artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma separated list of scope to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system, test).","include: a comma separated list of artifact to include in the artifact filtering.","exclude: a comma separated list of artifact to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included, true by default.","includeProjectComponentDependencies: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).","userArtifacts: set of component artifacts to include.","to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies, you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended practise is to use userArtifacts for the components and not the project <dependencies>.","ContainerDependenciesTransformer specific configuration is the following one:","repositoryBase: base repository location (default to MAVEN-INF/repository).","ignoredPaths: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","Example: if you want to list only the plugins you use you can configure this transformer like that:"]},{"lang":"en","title":"Configuring components","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/component-configuration.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Configuring components","In this article"],"lvl1":["Primitives","Complex object mapping","Constraints and validation on the configuration/input","Marking a configuration as a particular type of data","Define links between properties","Add hints about the rendering based on configuration/component knowledge"],"lvl2":["List case","Map case"],"text":["Component are configured through their constructor parameters. They can all be marked with @Option which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with -parameter flag to not have arg0, arg1, … as names).","The parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","it is recommanded to use simple models which can be serialized by components to avoid headaches when implementing serialized components.","Here is an example:","Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.","The instantiation of the parameters is done from the properties passed to the component (see next part).","What is considered as a primitive in this mecanism is a class which can be directly converted from a String to the expected type.","It obviously includes all java primitives, String type itself but also all the types with a org.apache.xbean.propertyeditor.Converter.","This includes out of the box:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from properties to object is using the dotted notation. For instance:","will match","assuming the method parameter was configured with @Option(\"file\").","Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named files and the elements are of FileOptions type, here is how to define a list of 2 elements:","Inspired from the list case, the map uses .key[index] and .value[index] to represent its key and values:","don’t abuse of map type. If not needed for your configuration (= if you can configure your component with an object) don’t use it.","It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the validation in org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a java pattern, you can use xregex library in javascript.","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones are the:","datastore: all the data you need to connect to the backend","dataset: a datastore coupled with all the data you need to execute an action","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","the component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.","Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.","For example, we can think about a relational database that support JDBC:","A datastore may provide:","jdbc url, username, password","A dataset may be:","datastore (that will provide the connection data to the database)","table name, data []","The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration into the targeted platforms (studio, web applications…)","The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.","Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.","For example, a configuration type index for the above example will be:","It can be needed to define a binding between properties, a set of annotations allows to do it:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","Target element location is specified as a relative path to current location using Unix path characters. Configuration class delimiter is /. Parent configuration class is specified by ... Thus ../targetProperty denotes a property, which is located in parent configuration class and has name targetProperty.","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration. A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper wants to influence the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first","second,third\",\"ui::gridlayout::value2::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","target support should cover org.talend.core.model.process.EParameterFieldType but we need to ensure web renderers is able to handle the same widgets."]},{"lang":"en","title":"Create an input component","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-create-an-input-component.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Create an input component","In this article"],"lvl1":["The component family registration","The component configuration","The Partition Mapper","The Producer (Source)"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The Assessor method","The Split method","The Emitter method","The full implementation of the Partition Mapper"],"text":["In this tutorial we will create a complete working input component for hazelcast.","This will include :","The component family registration.","The component configuration and the UI layout","The partition mapper that let the input split it self to work in a distributed environment.","The source that is responsible for connecting and reading data from the data source.","Getter and Setter methods are omitted for simplicity in this tutorial","We register the component family via a the package-info.java file in the package of the component.","The component configuration define the configurable part of the component in addition to the configuration type and the UI layout. The configuration is a simple POJO class decorated with annotations from the component framework. Here is the configuration of our component, that we will explain in details.","Read more about the component configuration…","As our component need to work first in distributed environments. Every input component has to define a partition mapper that will be responsible of calculating the number of sources to be created according to the hole dataset size and the requested bundle size by the targeted runner.","Let’s first start examining the skeleton of our partition mapper. Then we will implement every method one by one.","Now that we know what we need to implement and why. Let’s start coding those methods one by one.","Here is the HazelcastService implementation. Every class annotated with @Service can be injected to the component via it’s constructor.","Here is the implementation of the two methods used above","Here is the full code source for the partition mapper to have a global view of it. Read more about partition mapper…","Now that we have setup our component configuration and written our partition mapper that will create our producers. Let implement the source logic that will use the configuration provided by the mapper to read the records from the data source. To implement a source we need to implement the producer method that will produce a record every time it’s invoked.","Read more about source …","We have seen how to create a complete working input in this tutorial. In the next one we will explain how to create some unit tests for it."]},{"lang":"en","title":"Create components for REST API","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-create-components-rest-api.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Create components for REST API","In this article"],"lvl1":["Http client setup","Component Configuration","The component mapper","The component source"],"text":["In this tutorial we will show how to create components that consume a REST API.","As an example, we will develop an input component that will provide a search functionality for Zendesk using there Search API.","We use lambok. to get ride of getters, setters and constructors from our classes.","You can generate a project using the components kit starter as described in this tutorial.","As our input component will relay on Zendesk Search API. We will need an http client to consume it.","Zendesk Search API takes the following query parameters on this endpoint /api/v2/search.json.","query : The search query.","sort_by : One of updated_at, created_at, priority, status, or ticket_type. Defaults to sorting by relevance.","sort_order: One of asc or desc. Defaults to desc.","So let’s create our http client according to that.","Talend component kit provides a built-in service to create an easy to use http client in a declarative manner using java annotations.","And that all what we need to do to create our http client. No implementation is needed for the interface, as it will be provided by the component framework according to what we have defined.","This http client can be injected into a mapper or a processor to perform http requests.","For the sake of simplicity, we will use the basic authentication supported by the API.","Let’s start setting up the configuration for the basic authentication. To be able to consume the Search API, we will need to provide the Zendesk instance URL, the username and the password.","Now that we have our data store configuration. that will provide us with the basic authentication token. We need to setup our data set configuration. i.e the search query that will define the records that our input component will provide.","That’s all for the configuration part. Let’s create the component logic.","We will not split the http calls on many workers. so our mappers will not implement the split part.","Now we create the source that will perform the http request to the search api and convert the result to JsonObject records.","That all you will need to do to create a simple Talend component that consume a REST API.","In a next tutorial, we will show how to test this kind of component and use the component framework API simulation tools to create unit tests."]},{"lang":"en","title":"Creating a job pipeline","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-pipeline.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Creating a job pipeline","In this article"],"lvl1":["Job Builder","Beam case"],"lvl2":["Environment/Runner","Key Provider","I/O","Processors","Deployment","Convert a Beam.io in a component I/O"],"text":["The Job builder let you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, so you can built complex pipelines.","Let’s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write the result to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by an unique id and an URI that identify the component.","The URI follow the form : [family]://[component][?version][&configuration]","family: the name of the component family","component: the name of the component","version : the version of the component, it’s represented in a key=value format. where the key is __version and the value is a number.","configuration: here you can provide the component configuration as key=value tuple where the key is the path of the configuration and the value is the configuration value in string format.","configuration parameters must be URI/URL encoded.","Here is a more concrete job example:","It has some starting components (component that don’t have a from connection and that need to be of type producer).","There is no cyclic connections. as the job pipeline need to be an acyclic graph.","All the components used in connections are already declared.","The connection is used only once. you can’t connect a component input/output branch twice.","In this version, the execution of the job is linear. the component are not executed in parallel even if some steps may be independents.","Depending the configuration you can select which environment you execute your job in.","To select the environment the logic is the following one:","if an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder is passed through the job properties then use it (supported type are a ExecutionBuilder instance, a Class or a String).","if an ExecutionBuilder SPI is present then use it (it is the case if component-runtime-beam is present in your classpath).","else just use a local/standalone execution.","In the case of a Beam execution you can customize the pipeline options using system properties. They have to be prefixed by talend.beam.job.. For instance to set appName option you will set -Dtalend.beam.job.appName=mytest.","The job builder let you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job","If the incoming data has different ids you can provide a complex global key provider relaying on the context that give you the component id and the branch Name.","For beam case, you need to rely on beam pipeline definition and use component-runtime-beam dependency which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and integrate it in the pipeline.","The multiple inputs/outputs are represented by a Map element in beam case to avoid to use multiple inputs/outputs.","you can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, so a kind of Map<String, List<?>>, but materialized as a JsonObject. Input data must be of type JsonObject in this case.","Beam serializing components it is crucial to add component-runtime-standalone dependency to the project. It will take care of providing an implicit and lazy ComponentManager managing the component in a fatjar case.","For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your PTransform with @PartitionMapper or @Processor.","The limitation are:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and just register on the input PCollection a DoFn.","More information on that topic on How to wrap a Beam I/O page."]},{"lang":"en","title":"Gallery","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/gallery.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Gallery","In this article"],"lvl1":["Widgets","Validations"],"text":["Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Data store validation"]},{"lang":"en","title":"Generate a project using the component starter","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-generate-project-using-starter.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Generate a project using the component starter","In this article"],"lvl1":["Project configuration","Create an input component","Create a Processor component","Create an Output component","Generate and download the final project.","Compile and explore the generated project files"],"text":["The component starter let you design your components configuration and generate a ready to implement project structure.","In this tutorial, we will use the component starter to generate some components for MySQL database.","Choose your favorite build tool. we will use maven in this tutorial but you can select gradle if you prefer.","We add the test facet to get some unit tests generated automatically for the component that we will create after.","Complete the component description (family, and category).","Complete the project metadata. the groupId, ArtifactId and the package.","Click ADD A COMPONENT button to start designing your components.","Let’s create an input component that will connect to a MySQL database, execute a SQL query and get the result.","We choose the component type. INPUT in this case.","Give the component a cool name. MySQLInput is good enough.","This button will let us create the required configuration for our component. To be able to execute a SQL query, we will need a connection url, the username and the password for the database and the SQL query to be executed. Click the (+) button on the right to add a field and chose it type.","Our component will be an ordinary (non streaming) component. so just let this toggle button off.","Here we define the record type that this component will produce. we let it generic for now. as our component will generate some json records. You can also choose a custom type to define a POJO that will represent your records.","In this step we will create a very simple processor component that will receive a record, log it and return it at is.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give an explicit name to the component. RecordLogger, as our processor will log the records.","This is the configuration button. this component don’t need any configuration. so we just skip this step.","Here we define the inputs of the component. so click ADD INPUT button to create an input. In this component we will have only one input that will receive the record to be log.","click the input name to access it configuration. you can change the name and define the record model. Here we will use a generic record. otherwise you can use a POJO to represent the record.","Click ADD OUTPUT to create an output for this processor. we will need only one output as our logger only emit the received record. NOTE: the outputs are also configurable in the same way as the inputs (as explained in 5).","Now we will create an output component that will receive a record and insert it into a database table.","Output components are Processors without outputs. In other words, the output is a processor that don’t produce any records.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give the component a name. MySQLOutput","Create the component configuration. in this case we will need the connection url, the credentials of the database and the table name to insert the record in.","Like what we have done for the processor component above. we add an input","We make our input generic as we want to handle generic records in this component.","We don’t create any outputs for this component as it will not produce any records. this is the only difference betweene an output an a processor.","In the previous steps we have configured a project and created 3 components of different types (input, processor and output). Now click the GO TO FINISH button beside the ADD A COMPONENT button. You will be redirected to a summary page that shows :","Project configuration summary.","The list of the created components at the left panel.","You have two options to get the generated project. Download it locally as a zip file using the DOWNLOAD AS ZIP","Create a github repository and push the project to it using the button CREATE ON GITHUB.","Download the project as a zip to your local machine or clone it if you have created a github project.","As we have created a maven project here, we will use maven command to compile the project. In the project directory we execute the command mvn package","If you don’t have Maven installed on your machine, you can use the maven wrapper provided in the generated project. All you need is to execute the command: ./mvnw package","If you have created a gradle project you can compile with gradle build or use the gradle wrapper ./gradlew build","The generated project code contains documentation that will guide you to implement the component logic. so import the project to your favorite IDE and start implementing coding.","In the next tutorial, we will explain how to implement an Input component in details."]},{"lang":"en","title":"Generating data?","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-generating-data.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Generating data?","In this article"],"text":["Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Gradle Plugin","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/build-tools-gradle.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Gradle Plugin","In this article"],"text":["gradle-talend-component intends to help you to write components validating components match best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file the SDK uses to build the component classpath. For more information on the configuration you can check out the maven properties matching the attributes.","Here is how to use it:"]},{"lang":"en","title":"How to test a REST API","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-test-rest-api.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["How to test a REST API","In this article"],"text":["Testing code that consume REST API(s) can sometimes presents some difficulties, as you can face allot of constraints when dealing with them, like API rates limit, authentication tokens and passwords sharing, API availability, sandbox that expire or API’s cost that may be high…","As a developer you don’t want to care about all that, as all what you want to achieve is writing some good tests for your code logic. This is why, having the possibility to easily mock the API response is trivial.","The component framework provides an API simulation tool that make it easy to write unit tests. In this tutorial we will show how to use it in unit tests.","In this previous tutorial, we have created a component that consume Zendesk Search API. We will add some unit tests for it.","We have added 4 tickets that have the status open to our Zendesk test instance. that we will use in our tests","In our tutorial we will use some concept from component junit testing. You can refer to this page to read about the SimpleComponentRule …","L’est create a first unit test that will perform a real http request to Zendesk Search API instance. You can read how to create a simple unit test in this tutorial","So here we have created a complete working test. the test is performing real http request to our zendesk instance. but we may don’t want do that every time on the development environment. We may want to execute real http request only on an integration environment and on development environment use some mocked result to develop faster or for any other reasons.","Now we will transform this unit test to a mocked test that will use only mocked response of zendesk Search API. To do that you will need to add 2 junit rules provided by the component framework.","JUnit4HttpApi - this rule will start a simulation server that will act as a proxy and catch all the http requests performed inside the tests. This simulation server (proxy) have 2 modes :","capture : this mode will forward the captured http request to the real server and capture there response.","simulation : this mode will return a mocked response from the already captured responses. This rule need to be added as a class rule","JUnit4HttpApi - this rule have a reference to the first one and it role is to configure the simulation server for every unit test. it provide the simulation server by the running test context. This rule need to be added as a simple (method) rule.","Let’s add those 2 rules to our test to make it run in a simulation mode.","We almost done,","Now we need to run our test in capture mode to catch the real API responses to be able to use them later in the simulated mode.","To do that, we will have to set an environment variable talend.junit.http.capture to true. This will tel the simulation server to run in a capture mode. The captured response will be saved into resources/talend.testing.http package in a json format, then reused to perform API simulation.","Now you know how to easily mock your component that consume REST API."]},{"lang":"en","title":"Internationalization","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-internationalization.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Internationalization","In this article"],"lvl1":["Internationalization API"],"text":["Recommanded practise for internationalization are:","store messages using ResourceBundle properties file in your component module","the location of the properties are in the same package than the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties)","for your own messages use the internationalization API","Overal idea is to design its messages as methods returning String values and back the template by a ResourceBundle located in the same package than the interface defining these methods and named Messages.","this is the mecanism to use to internationalize your own messages in your own components.","To ensure you internationalization API is identified you need to mark it with @Internationalized:"]},{"lang":"en","title":"Internationalization","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/component-internationalization.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Internationalization","In this article"],"lvl1":["Default components keys"],"text":["In the simplest case you should store messages using ResourceBundle properties file in your component module to use internationalization. The location of the properties file should be in the same package as the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties).","Out of the box components are internationalized using the same location logic for the resource bundle and here is the list of supported keys:","Name Pattern","Description","${family}._displayName","the display name of the family","${family}.${configurationType}.${name}._displayName","the display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","the display name of the component (used by the GUIs)","${property_path}._displayName","the display name of the option.","${simple_class_name}.${property_name}._displayName","the display name of the option using it class name.","${property_path}._placeholder","the placeholder of the option.","Example of configuration for a component named list belonging to the family memory (@Emitter(family = \"memory\", name = \"list\")):","Configuration class are also translatable using the simple class name in the messages properties file. This useful when you have some common configuration shared within multiple components.","If you have a configuration class like :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.","If you have a display name using the property path, it will override the display name defined using the simple class name. this rule apply also to placeholders"]},{"lang":"en","title":"Mask your configuration sensitive data","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-configuration-sensitive-data.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Mask your configuration sensitive data","In this article"],"lvl1":["The component configuration","Mark sensitive data"],"text":["In this tutorial we will see how to ensure the sensitive data of a component configuration is correctly handled.","It is very common to define credentials in a component configuration. Most known use cases will be:","Passwords,","Secrets,","Potentially keys (it is also common to show them in plain text in a textarea),","Tokens","To illustrate that we will use a REST client configuration which takes a username, password and token to connect to the REST API:","This simple configuration defines three String without any specific widget so they will be represented as plain inputs.","There are two major consequences you probably want to avoid:","The password and token will be clearly readable in all Talend user interfaces (Studio or Web),","The password and token will be potentially stored in clear.","To solve that, Talend Component Kit provides you @Credential marker you can use on any @Option. This marker will have two effects:","Replace the default input widget by a password oriented one (See widgets gallery for screenshots),","Request the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).","To ensure our password and token are never stored in clear or shown in the code we migrate our previous model to the following one:","And that it is! Now your password and token will not be accessible by error anymore :).","Read more about the component configuration…"]},{"lang":"en","title":"Maven Plugin","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/build-tools-maven.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Maven Plugin","In this article"],"lvl1":["Dependencies","Validate","Documentation","Web","Generate inputs or outputs","Talend Component Archive"],"lvl2":["Render your documentation"],"lvl3":["HTML","PDF","Include the documentation into a document","More"],"text":["talend-component-maven-plugin intends to help you to write components validating components match best practices and also generating transparently metadata used by Talend Studio.","Here is how to use it:","Note that this plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin, it will create the TALEND-INF/dependencies.txt file with the compile and runtime dependencies to let the component use it at runtime:","The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:","By default it will be bound to process-classes phase. When executing it will do several validations which can be switched off adding the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates resource bundle are presents and contain commonly used keys (like _displayName)","true","validateModel","Ensure components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensure components are Serializable - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensure components define an @Icon and @Version.","true","validateDataStore","Ensure any @DataStore defines a @HealthCheck.","true","validateComponent","Ensure native programming model is respected, you can disable it when using another programming model like in beam case.","true","validateActions","Validate actions signatures for the ones not tolerating dynamic binding (@HealthCheck, @DynamicValues, …). It is recommanded to keep it true.","true","validateFamily","Validate the family, i.e. the package containing the @Components has also a @Icon.","true","validateDocumentation","Ensure all 1. components and 2. @Option properties have a documentation using @Documentation","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and @Documentation you can put on options and the component itself.","Name","Description","Default","level","Which level are the root title","2 which means ==","output","Where to store the output, it is NOT recommended to change it","${classes}/TALEND-INF/documentation.adoc","formats","A map of the renderings to do, keys are the format (pdf or html) and values the output paths","-","attributes","A map of asciidoctor attributes when formats is set","-","templateDir / templateEngine","Template configuration for the rendering","-","title","Document title","${project.name}","attachDocumentations","Should the documentations (.adoc, and formats keys) should be attached to the project (and deployed)","true","if you use the extension you can add the property talend.documentation.htmlAndPdf and set it to true in your project to automatically get a html and PDF rendering of the documentation.","To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):","Will generate in target/classes/TALEND-INF/documentation.adoc the components documentation.","Will render the documenation as an html file in target/documentation/documentation.html.","ensure to execute it after the documentation generation.","If you prefer a PDF rendering you can configure the following execution in the asciidoctor plugin (note that you can configure both executions if you want both HTML and PDF rendering):","If you want to add some more content or add a title, you can include the generated document into another document using Asciidoc include directive.","A common example is:","This assumes you pass to the plugin the attribute generated_doc, this can be done this way:","This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.","You can find more customizations on Asciidoctor website.","Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don’t forget the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering, you can use the goal web of the plugin:","Then you can test your component going on localhost:8080. You need to select which component form you want to see using the treeview on the left, then on the right the form will be displayed.","The two available configurations of the plugin are serverPort which is a shortcut to change the default, 8080, port of the embedded server and serverArguments to pass Meecrowave options to the server. More on that configuration is available at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","this command reads the component jar from the local maven repository so ensure to install the artifact before using it.","The Mojo generate (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration):","For this command to work you will need to just register the plugin:","Component ARchive (.car) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested maven repository containing the component and its depenencies.","It will create a .car in your build directory which is shareable on Talend platforms.","Note that this CAR is executable and exposes the command studio-deploy which takes as parameter a Talend Studio home location. Executed it will install the dependencies into the studio and register the component in your instance. Here is a sample launch command:"]},{"lang":"en","title":"Multiple environments for the same tests","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-multiple-envs.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Multiple environments for the same tests","In this article"],"lvl1":["JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl2":["Advanced usage"],"text":["JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job"]},{"lang":"en","title":"Providing some actions for consumers/clients","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-actions.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Providing some actions for consumers/clients","In this article"],"lvl1":["Particular action types"],"text":["In some cases you will desire to add some actions unrelated to the runtime. A simple example is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: does my database is up?.","To do so you need to define an @Action which is a method with a name (representing the event name) in a class decorated with @Service:","services are singleton so if you need some thread safety ensure they match that requirement. They shouldn’t store any state too (state is held by the component) since they can be serialized any time.","services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample with a service used to access files:","service is passed to constructor automatically, it can be used as a bean. Only call of service’s method is required.","Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks for instance. Here is the list of all actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Structure.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}"]},{"lang":"en","title":"Registering components","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/component-registering.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Registering components","In this article"],"lvl1":["Components metadata"],"lvl2":["Management of configuration versions","@PartitionMapper","@Processor"],"lvl3":["@Emitter"],"text":["As seen in the Getting Started, you need an annotation to register your component through family method. Multiple components can use the same family value but the pair family+name MUST be unique for the system.","If you desire (recommended) to share the same component family name instead of repeating yourself in all family methods, you can use @Components annotation on the root package of you component, it will enable you to define the component family and the categories the component belongs to (default is Misc if not set). Here is a sample package-info.java:","For an existing component it can look like:","Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information. These metadata are set on the component class and belongs to org.talend.sdk.component.api.component package.","API","Description","@Icon","Set an icon key used to represent the component. Note you can use a custom key with custom() method but it is not guaranteed the icon will be rendered properly.","@Version","Set the component version, default to 1.","Example:","If some impacting changes happen on the configuration they can be manage through a migration handler at component level (to enable to support trans-model migration).","The @Version annotation supports a migrationHandler method which will take the implementation migrating the incoming configuration to the current model.","For instance if filepath configuration entry from v1 changed to location in v2 you can remap the value to the right key in your MigrationHandler implementation.","it is recommanded to not manage all migrations in the handler but rather split it in services you inject in the migration handler (through constructor):","What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order you need to ensure they are sorted. Said otherwise: don’t see this API as a migration API but as a migration callback and adjust the migration code structure you need behind the MigrationHandler based on your component requirements. The service injection enables you to do so.","@PartitionMapper will obviously mark a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. Said otherwise it will enforce an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor will be considered as a producer factory:"]},{"lang":"en","title":"Search","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/search.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Search"]},{"lang":"en","title":"Secrets/Passwords and Maven","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-maven-passwords.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Secrets/Passwords and Maven","In this article"],"text":["If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details."]},{"lang":"en","title":"Services","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-services.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Services","In this article"],"lvl1":["Internationalization","Providing some actions for consumers/clients","Built in services","Services and interceptors","Creating a job pipeline","Advanced: define a custom API"],"lvl2":["Internationalization API","Particular action types","HttpClient usage","Job Builder","Beam case","Extending the UI"],"lvl3":["Advanced HTTP client request customization","Environment/Runner","Key Provider","I/O","Processors","Deployment","Convert a Beam.io in a component I/O"],"text":["Recommanded practise for internationalization are:","store messages using ResourceBundle properties file in your component module","the location of the properties are in the same package than the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties)","for your own messages use the internationalization API","Overal idea is to design its messages as methods returning String values and back the template by a ResourceBundle located in the same package than the interface defining these methods and named Messages.","this is the mecanism to use to internationalize your own messages in your own components.","To ensure you internationalization API is identified you need to mark it with @Internationalized:","In some cases you will desire to add some actions unrelated to the runtime. A simple example is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: does my database is up?.","To do so you need to define an @Action which is a method with a name (representing the event name) in a class decorated with @Service:","services are singleton so if you need some thread safety ensure they match that requirement. They shouldn’t store any state too (state is held by the component) since they can be serialized any time.","services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample with a service used to access files:","service is passed to constructor automatically, it can be used as a bean. Only call of service’s method is required.","Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks for instance. Here is the list of all actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Structure.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","The framework provides some built-in services you can inject by type in components and actions out of the box.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data which don’t need to be recomputed very often. Commonly used by actions for the UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","it assumes the dependency is locally available to the execution instance which is not guaranteed yet by the framework.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration which can be used during the design.","it is not recommanded to use it for the runtime since the local configuration is generally different and the instances are distincts.","you can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","This let you define an http client in a declarative manner using an annotated interface.","See the HttpClient usage for details.","Let assume that we have a REST API defined like below, and that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","with a json playload to be created {\"id\":\"some id\", \"data\":\"some data\"}","To create an http client able to consume this REST API, we will define an interface that extends HttpClient,","The HttpClient interface lets you set the base for the http address that our client will hit.","The base is the part of the address that we will need to add to the request path to hit the api.","Every method annotated with @Request of our interface will define an http request. Also every request can have @Codec that let us encode/decode the request/response playloads.","if your payload(s) is(are) String or Void you can ignore the coder/decoder.","The interface should extends HttpClient.","In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with @Service or @Internationalized into the constructor. The i18n services can be useful to have i18n messages for errors handling for example.","This interface can be injected into our Components classes or Services to consume the defined api.","Note: by default /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases you can customize the Connection directly using @UseConfigurer on the method. It will call your custom instance of Configurer. Note that you can use some @ConfigurerOption in the method signature to pass some configurer configuration.","For instance if you have this configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:","For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework on services.","An interceptor defines an annotation marked with @Intercepts which defines the implementation of the interceptor (an InterceptorHandler).","Here is an example:","Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be a BiFunction<Method, Object[], Object> which representes the invocation chain if your interceptor can be used with others.","if you do a generic interceptor it is important to pass the invoker as first parameter. If you don’t do so you can’t combine interceptors at all.","Here is an interceptor implementation for our @Logged API:","This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.","the findAnnotation annotation - inherited from InterceptorHandler is an utility method to find an annotation on a method or class (in this order).","The Job builder let you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, so you can built complex pipelines.","Let’s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write the result to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by an unique id and an URI that identify the component.","The URI follow the form : [family]://[component][?version][&configuration]","family: the name of the component family","component: the name of the component","version : the version of the component, it’s represented in a key=value format. where the key is __version and the value is a number.","configuration: here you can provide the component configuration as key=value tuple where the key is the path of the configuration and the value is the configuration value in string format.","configuration parameters must be URI/URL encoded.","Here is a more concrete job example:","It has some starting components (component that don’t have a from connection and that need to be of type producer).","There is no cyclic connections. as the job pipeline need to be an acyclic graph.","All the components used in connections are already declared.","The connection is used only once. you can’t connect a component input/output branch twice.","In this version, the execution of the job is linear. the component are not executed in parallel even if some steps may be independents.","Depending the configuration you can select which environment you execute your job in.","To select the environment the logic is the following one:","if an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder is passed through the job properties then use it (supported type are a ExecutionBuilder instance, a Class or a String).","if an ExecutionBuilder SPI is present then use it (it is the case if component-runtime-beam is present in your classpath).","else just use a local/standalone execution.","In the case of a Beam execution you can customize the pipeline options using system properties. They have to be prefixed by talend.beam.job.. For instance to set appName option you will set -Dtalend.beam.job.appName=mytest.","The job builder let you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job","If the incoming data has different ids you can provide a complex global key provider relaying on the context that give you the component id and the branch Name.","For beam case, you need to rely on beam pipeline definition and use component-runtime-beam dependency which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and integrate it in the pipeline.","The multiple inputs/outputs are represented by a Map element in beam case to avoid to use multiple inputs/outputs.","you can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, so a kind of Map<String, List<?>>, but materialized as a JsonObject. Input data must be of type JsonObject in this case.","Beam serializing components it is crucial to add component-runtime-standalone dependency to the project. It will take care of providing an implicit and lazy ComponentManager managing the component in a fatjar case.","For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your PTransform with @PartitionMapper or @Processor.","The limitation are:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and just register on the input PCollection a DoFn.","More information on that topic on How to wrap a Beam I/O page.","It is possible to extend the Component API for custom front features.","What is important here is to keep in mind you should do it only if it targets not portable components (only used by the Studio or Beam).","In term of organization it is recommanded to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI just add an annotation which can be put on @Option fields which is decorated with @Ui. All its members will be put in the metadata of the parameter. Example:"]},{"lang":"en","title":"Services and interceptors","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/services-interceptors.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Services and interceptors","In this article"],"text":["For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework on services.","An interceptor defines an annotation marked with @Intercepts which defines the implementation of the interceptor (an InterceptorHandler).","Here is an example:","Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be a BiFunction<Method, Object[], Object> which representes the invocation chain if your interceptor can be used with others.","if you do a generic interceptor it is important to pass the invoker as first parameter. If you don’t do so you can’t combine interceptors at all.","Here is an interceptor implementation for our @Logged API:","This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.","the findAnnotation annotation - inherited from InterceptorHandler is an utility method to find an annotation on a method or class (in this order)."]},{"lang":"en","title":"Talend Component Appendix","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/appendix.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Appendix","In this article"],"lvl1":["ContainerManager or the classloader manager"],"lvl2":["Listener for plugin registration"],"text":["The entry point of the API is the ContainerManager, it will enable you to define what is the Shared classloader and to create children:","Once you have a manager you can create plugins:","To create the plugin container, the Resolver will resolve the dependencies needed for the plugin, then the manager will create the plugin classloader and register the plugin Container.","It is common to need to do some actions when a plugin is registered/unregistered. For that purpose ContainerListener can be used:","They are registered on the manager directly:"]},{"lang":"en","title":"Talend Component Best Practices","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/best-practices.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Best Practices","In this article"],"lvl1":["Organize your code","Modelize your configuration","I/O configuration","Processor configuration","I/O recommandations","I/O limitations","Handle UI interactions","Version and component","Don’t forget to test","Contribute to this guide"],"lvl2":["Validations","Completion","Don’t forget the component representation"],"lvl3":["Light validations","Custom validations"],"text":["Few recommandations apply to the way a component packages are organized:","ensure to create a package-info.java with the component family/categories at the root of your component package:","create a package for the configuration","create a package for the actions","create a package for the component and one subpackage by type of component (input, output, processors, …)","It is recommanded to ensure your configuration is serializable since it is likely you will pass it through your components which can be serialized.","The first step to build a component is to identify the way it must be configured.","It is generally split into two main big concepts:","the DataStore which is the way you can access the backend","the DataSet which is the way you interact with the backend","Here are some examples to let you get an idea of what you put in each categories:","Example description","DataStore","DataSet","Accessing a relational database like MySQL","the JDBC driver, url, username and password","the query to execute, row mapper, …","Access a file system","the file pattern (or directory + file extension/prefix/…)","the file format, potentially the buffer size, …","It is common to make the dataset including the datastore since both are required to work. However it is recommanded to replace this pattern by composing both in a higher level configuration model:","Processor configuration is simpler than I/O configuration since it is specific each time. For instance a mapper will take the mapping between the input and output model:","I/O are particular because they can be linked to a set of actions. It is recommanded to wire all the ones you can apply to ensure the consumers of your component can provide a rich experience to their users.","Here are the most common ones:","Type","Action","Description","Configuration example","Action example","DataStore","@Checkable","Expose a way to ensure the datastore/connection works","Until the studio integration is complete, it is recommanded to limit processors to 1 input.","It is also recommanded to provide as much information as possible to let the UI work with the data during its edition.","The light validations are all the validations you can execute on the client side. They are listed in the UI hint part.","This is the ones to use first before going with custom validations since they will be more efficient.","These ones will enforce custom code to be executed, they are more heavy so try to avoid to use them for simple validations you can do with the previous part.","Here you define an action taking some parameters needed for the validation and you link the option you want to validate to this action. Here is an example to validate a dataset. For example for our JDBC driver we could have:","Note that you can also make a class validable and you can use it to validate a form if you put it on your whole configuration:","the parameter binding of the validation method uses the same logic than the component configuration injection. Therefore the @Option specifies the prefix to use to reference a parameter. It is recommanded to use @Option(\"value\") until you know exactly why you don’t use it. This way the consumer can match the configuration model and just prefix it with value. to send the instance to validate.","It can be neat and user friendly to provide completion on some fields. Here an example for the available drivers:","Each component must have its own icon:","you can use talend.surge.sh/icons/ to identify the one you want to use.","Not mandatory for the first version but recommanded: enforce the version of your component.","If you break a configuration entry in a later version ensure to:","upgrade the version","support a migration of the configuration","Testing the components is crucial, you can use unit tests and simple standalone JUnit but it is highly recommanded to have a few Beam tests to ensure your component works in Big Data world.","Don’t hesitate to send your feedback on writing component and best practices you can encounter."]},{"lang":"en","title":"Talend Component Design Choices","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/design.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Design Choices","In this article"],"lvl1":["Component API","Isolated","REST","Fixed set of icons"],"lvl2":["Evolution","Static","Flexible data modeling","Generic and specific","Consumable model","Execution with streaming"],"lvl3":["UI friendly","Auditable and with clear expectations","Dev friendly","No runtime assumption"],"text":["The component API has multiple strong choices:","it is declarative (through annotations) to ensure it is","evolutive (it can get new fancy featrues without breaking old code)","static as much as possible","Being fully declarative, any new API can be added iteratively without requiring any changes to existing components.","Example (projection on beam potential evolution):","wouldn’t be affected by the addition of the new Timer API which can be used like:","Intent of the framework is to be able to fit java UI as well as web UI. It must be understood as colocalized and remote UI. The direct impact of that choice is to try to move as much as possible the logic to the UI side for UI related actions. Typically we want to validate a pattern, a size, … on the client side and not on the server side. Being static encourages this practise.","The other goal to be really static in its definition is to ensure the model will not be mutated at runtime and all the auditing and modelling can be done before, in the design phase.","Being static also ensures the development can be validated as much as possible through build tools. This doesn’t replace the requirement to test the components but helps the developer to maintain its components with automated tools.","The processor API supports JsonObject as well as any custom model. Intent is to support generic component development which need to access configured \"object paths\" and specific components which rely on a well defined path from the input.","A generic component would look like:","A specific component would look like (with MyInput a POJO):","By design the framework must run in DI (plain standalone java program) but also in Beam pipelines. It is also out of scope of the framework to handle the way the runtime serializes - if needed - the data. For that reason it is primordial to not import serialization constraint in the stack. This is why JsonObject is not an IndexedRecord from avro for instance, to not impose any implementation. Any actual serialization concern - implementation - should either be hidden in the framework runtime (= outside component developer scope) or in the runtime integration with the framework (beam integration for instance). In this context, JSON-P is a good compromise because it brings a very powerful API with very few constraints.","The components must be able to execute even if they have conflicting libraries. For that purpose it requires to isolate their classloaders. For that purpose a component will define its dependencies based on a maven format and will always be bound to its own classloader.","The definition payload is as flat as possible and strongly typed to ensure it can be manipulated by consumers. This way the consumers can add/remove fields with just some mapping rules and don’t require any abstract tree handling.","The execution (runtime) configuration is the concatenation of a few framework metadata (only the version actually) and a key/value model of the instance of the configuration based on the definition properties paths for the keys. This enables the consumers to maintain and work with the keys/values up to their need.","The framework not being responsible for any persistence it is crucial to ensure consumers can handle it from end to end which includes the ability to search for values (update a machine, update a port etc…) and keys (new encryption rule on key certificate for instance).","Talend component is a metamodel provider (to build forms) and runtime execution platform (take a configuration instance and use it volatively to execute a component logic). This implies it can’t own the data more than defining the contract it has for these two endpoints and must let the consumers handle the data lifecycle (creation, encryption, deletion, ….).","A new mime type called talend/stream is introduced to define a streaming format.","It basically matches a JSON object per line:","Icons (@Icon) are based on a fixed set. Even if a custom icon is usable this is without any guarantee. This comes from the fact components can be used in any environment and require a kind of uniform look which can’t be guaranteed outside the UI itself so defining only keys is the best way to communicate this information.","when you exactly know how you will deploy your component (ie in the Studio) then you can use `@Icon(value = CUSTOM, custom = \"…\") to use a custom icon file."]},{"lang":"en","title":"Talend Component Documentation","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/other.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Documentation","In this article"],"lvl1":["Talend Component Testing Documentation"],"lvl2":["Best practises","component-runtime-testing","Beam testing","Multiple environments for the same tests","Secrets/Passwords and Maven","Generating data?"],"lvl3":["Parameterized tests","component-runtime-junit","component-runtime-testing-spark","component-runtime-http-junit","JUnit 4","JUnit 5","Provided environments","Configuring environments"],"text":["this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature.","component-runtime-junit is a small test library allowing you to validate simple logic based on Talend Component tooling.","To import it add to your project the following dependency:","This dependency also provide some mocked components that you can use with your own component to create tests.","The mocked components are provided under the family test :","emitter : a mock of an input component","collector : a mock of an output component","Then you can define a standard JUnit test and use the SimpleComponentRule rule:","The JUnit 5 integration is mainly the same as for JUnit 4 except it uses the new JUnit 5 extension mecanism.","The entry point is the @WithComponents annotation you put on your test class which takes the component package you want to test and you can use @Injected to inject in a test class field an instance of ComponentsHandler which exposes the same utilities than the JUnit 4 rule:","if it is the first time you use JUnit 5, don’t forget the imports changed and you must use org.junit.jupiter.api.Test instead of org.junit.Test. Some IDE versions and surefire versions can also need you to install either a plugin or a specific configuration.","Using the component \"test\"/\"collector\" as in previous sample stores all records emitted by the chain (typically your source) in memory, you can then access them using theSimpleComponentRule.getCollectoedRecord(type). Note that this method filters by type, if you don’t care of the type just use Object.class.","The input mocking is symmetric to the output but here you provide the data you want to inject:","The component configuration is a POJO (using @Option on fields) and the runtime configuration (ExecutionChainBuilder) uses a Map<String, String>. To make the conversion easier, the JUnit integration provides a SimpleFactory.configurationByExample utility to get this map instance from a configuration instance.","Example:","The same factory provides a fluent DSL to create configuration calling configurationByExample without any parameter. The advantage is to be able to convert an object as a Map<String, String> as seen previously or as a query string to use it with the Job DSL:","It handles the encoding of the URI to ensure it is correctly done.","The SimpleComponentRule also allows to test a mapper unitarly, you can get an instance from a configuration and you can execute this instance to collect the output. Here is a snippet doing that:","As for the mapper a processor is testable unitary. The case is a bit more complex since you can have multiple inputs and outputs:","Here again the rule allows you to instantiate a Processor from your code and then to collect the output from the inputs you pass in. There are two convenient implementation of the input factory:","MainInputFactory for processors using only the default input.","JoinInputfactory for processors using multiple inputs have a method withInput(branch, data) The first arg is the branch name and the second arg is the data used by the branch.","you can also implement your own input representation if needed implementing org.talend.sdk.component.junit.ControllableInputFactory.","The folowing artifact will allow you to test against a spark cluster:","The usage relies on a JUnit TestRule. It is recommanded to use it as a @ClassRule to ensure a single instance of a spark cluster is built but you can also use it as a simple @Rule which means it will be created per method instead of per test class.","It takes as parameter the spark and scala version to use. It will then fork a master and N slaves. Finally it will give you submit* method allowing you to send jobs either from the test classpath or from a shade if you run it as an integration test.","Here is a sample:","this is working with @Parameterized so you can submit a bunch of jobs with different args and even combine it with beam TestPipeline if you make it transient!","The integration with JUnit 5 of that spark cluster logic uses @WithSpark marker for the extension and let you, optionally, inject through @SparkInject, the BaseSpark<?> handler to access te spark cluster meta information - like its host/port.","Here is a basic test using it:","In current state, SparkClusterRule doesn’t allow to know a job execution is done - even if it exposes the webui url so you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.","awaitability or equivalent library can help you to write such logic.","Here are the coordinates of the artifact:","And here is how to wait a file exists and its content (for instance) is the expected one:","The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:","this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier shaded to the dependency and the two dependencies are shaded avoiding the conflicts with your component.","It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.","You can plug your own ResponseLocator to map a request to a response but the default implementation - which should be sufficient in most cases - will look in talend/testing/http/<class name>_<method name>.json. Note that you can also put it in talend/testing/http/<request path>.json.","JUnit 4 setup is done through two rules: JUnit4HttpApi which is responsible to start the server and JUnit4HttpApiPerMethodConfigurator which is responsible to configure the server per test and also handle the capture mode (see later).","if you don’t use the JUnit4HttpApiPerMethodConfigurator, the capture feature will be deactivated and the per test mocking will not be available.","Most of the test will look like:","For tests using SSL based services, you will need to use activeSsl() on the JUnit4HttpApi rule.","If you need to access the server ssl socket factory you can do it from the HttpApiHandler (the rule):","JUnit 5 uses a JUnit 5 extension based on the HttpApi annotation you can put on your test class. You can inject the test handler (which has some utilities for advanced cases) through @HttpApiInject:","the injection is optional and the @HttpApi allows you to configure several behaviors of the test.","For tests using SSL based services, you will need to use @HttpApi(useSsl = true).","You can access the client SSL socket factory through the api handler:","The strength of this implementation is to run a small proxy server and auto configure the JVM: http[s].proxyHost, http[s].proxyPort, HttpsURLConnection#defaultSSLSocketFactory and SSLContext#default are auto configured to work out of the box with the proxy.","It allows you to keep in your tests the native and real URLs. For instance this test is perfectlt valid:","If you execute this test, it will fail with a HTTP 400 because the proxy doesn’t find the mocked response. You can create it manually as seen in the introduction of the module but you can also set the property talend.junit.http.capture to the folder where to store the captures. It must be the root folder and not the folder where the json are (ie not prefixed by talend/testing/http by default).","Generally you will want to use src/test/resources. If new File(\"src/test/resources\") resolves to the valid folder when executing your test (Maven default), then you can just set the system property to true, otherwise you need to adjust accordingly the system property value.","Once you ran the tests with this system property, the testing framework will have created the correct mock response files and you can remove the system property. The test will still pass, using google.com…even if you disconnect your machine from the internet.","The rule (extension) is doing all the work for you :).","Setting talend.junit.http.passthrough system property to true, the server will just be a proxy and will execute each request to the actual server - like in capturing mode.","If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details.","JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job","If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details.","Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Talend Component Documentation","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Documentation","In this article"],"lvl1":["Talend Components Definitions Documentation","Components Packaging","Build tools","Services","Talend Component Testing Documentation"],"lvl2":["Components Definition","Configuring components","Gallery","Registering components","Internationalization","Component Loading","Maven Plugin","Gradle Plugin","Internationalization","Providing some actions for consumers/clients","Built in services","Services and interceptors","Creating a job pipeline","Advanced: define a custom API","Best practises","component-runtime-testing","Beam testing","Multiple environments for the same tests","Secrets/Passwords and Maven","Generating data?"],"lvl3":["PartitionMapper","Definition","Producer","Processor","Multiple outputs","Multiple inputs","Output","Combiners?","Primitives","Complex object mapping","Constraints and validation on the configuration/input","Marking a configuration as a particular type of data","Define links between properties","Add hints about the rendering based on configuration/component knowledge","Widgets","Validations","Components metadata","Default components keys","Packaging a plugin","Packaging an application","Dependencies","Validate","Documentation","Web","Generate inputs or outputs","Talend Component Archive","Internationalization API","Particular action types","HttpClient usage","Job Builder","Beam case","Extending the UI","Parameterized tests","component-runtime-junit","component-runtime-testing-spark","component-runtime-http-junit","JUnit 4","JUnit 5","Provided environments","Configuring environments"],"text":["Talend Component framework relies on several primitive components.","They can all use @PostConstruct and @PreDestroy to initialize/release some underlying resource at the beginning/end of the processing.","in distributed environments class' constructor will be called on cluster manager node, methods annotated with @PostConstruct and @PreDestroy annotations will be called on worker nodes. Thus, partition plan computation and pipeline task will be performed on different nodes.","","Created task consists of Jar file, containing class, which describes pipeline(flow) which should be processed in cluster.","During partition plan computation step pipeline is analyzed and split into stages. Cluster Manager node instantiates mappers/processors gets estimated data size using mappers, splits created mappers according to the estimated data size. All instances are serialized and sent to Worker nodes afterwards.","Serialized instances are received and deserialized, methods annotated with @PostConstruct annotation are called. After that, pipeline execution is started. Processor’s @BeforeGroup annotated method is called before processing first element in chunk. After processing number of records estimated as chunk size, Processor’s @AfterGroup annotated method called. Chunk size is calculated depending on environment the pipeline is processed by. After pipeline is processed, methods annotated with @PreDestroy annotation are called.","","","all framework managed methods MUST be public too. Private methods are ignored.","in term of design the framework tries to be as declarative as possible but also to stay extensible not using fixed interfaces or method signatures. This will allow to add incrementally new features of the underlying implementations.","A PartitionMapper is a component able to split itself to make the execution more efficient.","This concept is borrowed to big data world and useful only in this context (BEAM executions). Overall idea is to divide the work before executing it to try to reduce the overall execution time.","The process is the following:","Estimate the size of the data you will work on. This part is often heuristic and not very precise.","From that size the execution engine (runner for beam) will request the mapper to split itself in N mappers with a subset of the overall work.","The leaf (final) mappers will be used as a Producer (actual reader) factory.","this kind of component MUST be Serializable to be distributable.","A partition mapper requires 3 methods marked with specific annotations:","@Assessor for the evaluating method","@Split for the dividing method","@Emitter for the Producer factory","The assessor method will return the estimated size of the data related to the component (depending its configuration). It MUST return a Number and MUST not take any parameter.","Here is an example:","The split method will return a collection of partition mappers and can take optionally a @PartitionSize long value which is the requested size of the dataset per sub partition mapper.","Here is an example:","The emitter method MUST not have any parameter and MUST return a producer. It generally uses the partition mapper configuration to instantiate/configure the producer.","Here is an example:","A Producer is the component interacting with a physical source. It produces input data for the processing flow.","A producer is a very simple component which MUST have a @Producer method without any parameter and returning any data:","A Processor is a component responsible to convert an incoming data to another model.","A processor MUST have a method decorated with @ElementListener taking an incoming data and returning the processed data:","this kind of component MUST be Serializable since it is distributed.","if you don’t care much of the type of the parameter and need to access data on a \"map like\" based rule set, then you can use JsonObject as parameter type and Talend Component will just wrap the data to enable you to access it as a map. The parameter type is not enforced, i.e. if you know you will get a SuperCustomDto then you can use that as parameter type but for generic component reusable in any chain it is more than highly encouraged to use JsonObject until you have your an evaluation language based processor (which has its own way to access component). Here is an example:","A processor also supports @BeforeGroup and @AfterGroup which MUST be methods without parameters and returning void (result would be ignored). This is used by the runtime to mark a chunk of the data in a way which is estimated good for the execution flow size.","this is estimated so you don’t have any guarantee on the size of a group. You can literally have groups of size 1.","The common usage is to batch records for performance reasons:","it is a good practise to support a maxBatchSize here and potentially commit before the end of the group in case of a computed size which is way too big for your backend.","In some case you may want to split the output of a processor in two. A common example is \"main\" and \"reject\" branches where part of the incoming data are put in a specific bucket to be processed later.","This can be done using @Output. This can be used as a replacement of the returned value:","Or you can pass it a string which will represent the new branch:","Having multiple inputs is closeto the output case excep it doesn’t require a wrapper OutputEmitter:","@Input takes the input name as parameter, if not set it uses the main (default) input branch.","due to the work required to not use the default branch it is recommanded to use it when possible and not name its branches depending on the component semantic.","An Output is a Processor returning no data.","Conceptually an output is a listener of data. It perfectly matches the concept of processor. Being the last of the execution chain or returning no data will make your processor an output:","For now Talend Component doesn’t enable you to define a Combiner. It would be the symmetric part of the partition mapper and allow to aggregate results in a single one.","Component are configured through their constructor parameters. They can all be marked with @Option which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with -parameter flag to not have arg0, arg1, … as names).","The parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","it is recommanded to use simple models which can be serialized by components to avoid headaches when implementing serialized components.","Here is an example:","Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.","The instantiation of the parameters is done from the properties passed to the component (see next part).","What is considered as a primitive in this mecanism is a class which can be directly converted from a String to the expected type.","It obviously includes all java primitives, String type itself but also all the types with a org.apache.xbean.propertyeditor.Converter.","This includes out of the box:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from properties to object is using the dotted notation. For instance:","will match","assuming the method parameter was configured with @Option(\"file\").","Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named files and the elements are of FileOptions type, here is how to define a list of 2 elements:","Inspired from the list case, the map uses .key[index] and .value[index] to represent its key and values:","don’t abuse of map type. If not needed for your configuration (= if you can configure your component with an object) don’t use it.","It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the validation in org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a java pattern, you can use xregex library in javascript.","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones are the:","datastore: all the data you need to connect to the backend","dataset: a datastore coupled with all the data you need to execute an action","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","the component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.","Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.","For example, we can think about a relational database that support JDBC:","A datastore may provide:","jdbc url, username, password","A dataset may be:","datastore (that will provide the connection data to the database)","table name, data []","The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration into the targeted platforms (studio, web applications…)","The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.","Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.","For example, a configuration type index for the above example will be:","It can be needed to define a binding between properties, a set of annotations allows to do it:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","Target element location is specified as a relative path to current location using Unix path characters. Configuration class delimiter is /. Parent configuration class is specified by ... Thus ../targetProperty denotes a property, which is located in parent configuration class and has name targetProperty.","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration. A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper wants to influence the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first","second,third\",\"ui::gridlayout::value2::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","target support should cover org.talend.core.model.process.EParameterFieldType but we need to ensure web renderers is able to handle the same widgets.","Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Data store validation","As seen in the Getting Started, you need an annotation to register your component through family method. Multiple components can use the same family value but the pair family+name MUST be unique for the system.","If you desire (recommended) to share the same component family name instead of repeating yourself in all family methods, you can use @Components annotation on the root package of you component, it will enable you to define the component family and the categories the component belongs to (default is Misc if not set). Here is a sample package-info.java:","For an existing component it can look like:","Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information. These metadata are set on the component class and belongs to org.talend.sdk.component.api.component package.","API","Description","@Icon","Set an icon key used to represent the component. Note you can use a custom key with custom() method but it is not guaranteed the icon will be rendered properly.","@Version","Set the component version, default to 1.","Example:","If some impacting changes happen on the configuration they can be manage through a migration handler at component level (to enable to support trans-model migration).","The @Version annotation supports a migrationHandler method which will take the implementation migrating the incoming configuration to the current model.","For instance if filepath configuration entry from v1 changed to location in v2 you can remap the value to the right key in your MigrationHandler implementation.","it is recommanded to not manage all migrations in the handler but rather split it in services you inject in the migration handler (through constructor):","What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order you need to ensure they are sorted. Said otherwise: don’t see this API as a migration API but as a migration callback and adjust the migration code structure you need behind the MigrationHandler based on your component requirements. The service injection enables you to do so.","@PartitionMapper will obviously mark a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. Said otherwise it will enforce an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor will be considered as a producer factory:","In the simplest case you should store messages using ResourceBundle properties file in your component module to use internationalization. The location of the properties file should be in the same package as the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties).","Out of the box components are internationalized using the same location logic for the resource bundle and here is the list of supported keys:","Name Pattern","Description","${family}._displayName","the display name of the family","${family}.${configurationType}.${name}._displayName","the display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","the display name of the component (used by the GUIs)","${property_path}._displayName","the display name of the option.","${simple_class_name}.${property_name}._displayName","the display name of the option using it class name.","${property_path}._placeholder","the placeholder of the option.","Example of configuration for a component named list belonging to the family memory (@Emitter(family = \"memory\", name = \"list\")):","Configuration class are also translatable using the simple class name in the messages properties file. This useful when you have some common configuration shared within multiple components.","If you have a configuration class like :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.","If you have a display name using the property path, it will override the display name defined using the simple class name. this rule apply also to placeholders","Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts it requires to isolate plugins (components or component grouped in a single jar/plugin).","Here we have multiple options which are (high level):","flat classpath: listed for completeness but rejected by design because it doesn’t match at all this requirement.","tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes are not seen by the shared classloader nor by other plugins.","graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.","If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications and the graph classloading can be illustrated by OSGi containers.","In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage is you don’t need to define the relationship with other plugins/dependencies (it is built-in).","Here is a representation of this solution:","","The interesting part is the shared area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.","Then each plugins will be loaded in their own classloader with their dependencies.","this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.","A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt location so you just need to ensure your component defines the following plugin:","If you check your jar once built you will see that the file contains something like:","What is important to see is the scope associated to the artifacts:","the API (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (it comes with the framework)","your specific dependencies (awesome-project) is compile: it will be included as a needed dependency by the framework (note that using runtime works too).","the other dependencies will be ignored (test dependencies)","Even if a flat classpath deployment is possible, it is not recommanded because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:","This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component runtime has two ways to find an artifact:","from the file system based on a configure maven 2 repository.","from a fatjar (uber jar) with a nested maven repository under MAVEN-INF/repository.","The first option will use either - by default - ${user.home}/.m2/repository or a specific path configured when creating a ComponentManager. The nested repository option will need some configuration during the packaging to ensure the repository is well created.","To create the nested MAVEN-INF/repository repository you can use nested-maven-repository extension:","Plugin are programmatically registered in general but if you want to make some of them automatically available you need to generate a TALEND-INF/plugins.properties which will map a plugin name to coordinates found with the maven mecanism we just talked about.","Here again we can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven shade plugin:","the configuration unrelated to transformers can depend your application.","ContainerDependenciesTransformer is the one to embed a maven repository and PluginTransformer to create a file listing (one per line) a list of artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma separated list of scope to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system, test).","include: a comma separated list of artifact to include in the artifact filtering.","exclude: a comma separated list of artifact to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included, true by default.","includeProjectComponentDependencies: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).","userArtifacts: set of component artifacts to include.","to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies, you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended practise is to use userArtifacts for the components and not the project <dependencies>.","ContainerDependenciesTransformer specific configuration is the following one:","repositoryBase: base repository location (default to MAVEN-INF/repository).","ignoredPaths: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","Example: if you want to list only the plugins you use you can configure this transformer like that:","talend-component-maven-plugin intends to help you to write components validating components match best practices and also generating transparently metadata used by Talend Studio.","Here is how to use it:","Note that this plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin, it will create the TALEND-INF/dependencies.txt file with the compile and runtime dependencies to let the component use it at runtime:","The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:","By default it will be bound to process-classes phase. When executing it will do several validations which can be switched off adding the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates resource bundle are presents and contain commonly used keys (like _displayName)","true","validateModel","Ensure components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensure components are Serializable - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensure components define an @Icon and @Version.","true","validateDataStore","Ensure any @DataStore defines a @HealthCheck.","true","validateComponent","Ensure native programming model is respected, you can disable it when using another programming model like in beam case.","true","validateActions","Validate actions signatures for the ones not tolerating dynamic binding (@HealthCheck, @DynamicValues, …). It is recommanded to keep it true.","true","validateFamily","Validate the family, i.e. the package containing the @Components has also a @Icon.","true","validateDocumentation","Ensure all 1. components and 2. @Option properties have a documentation using @Documentation","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and @Documentation you can put on options and the component itself.","Name","Description","Default","level","Which level are the root title","2 which means ==","output","Where to store the output, it is NOT recommended to change it","${classes}/TALEND-INF/documentation.adoc","formats","A map of the renderings to do, keys are the format (pdf or html) and values the output paths","-","attributes","A map of asciidoctor attributes when formats is set","-","templateDir / templateEngine","Template configuration for the rendering","-","title","Document title","${project.name}","attachDocumentations","Should the documentations (.adoc, and formats keys) should be attached to the project (and deployed)","true","if you use the extension you can add the property talend.documentation.htmlAndPdf and set it to true in your project to automatically get a html and PDF rendering of the documentation.","To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):","Will generate in target/classes/TALEND-INF/documentation.adoc the components documentation.","Will render the documenation as an html file in target/documentation/documentation.html.","ensure to execute it after the documentation generation.","If you prefer a PDF rendering you can configure the following execution in the asciidoctor plugin (note that you can configure both executions if you want both HTML and PDF rendering):","If you want to add some more content or add a title, you can include the generated document into another document using Asciidoc include directive.","A common example is:","This assumes you pass to the plugin the attribute generated_doc, this can be done this way:","This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.","You can find more customizations on Asciidoctor website.","Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don’t forget the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering, you can use the goal web of the plugin:","Then you can test your component going on localhost:8080. You need to select which component form you want to see using the treeview on the left, then on the right the form will be displayed.","The two available configurations of the plugin are serverPort which is a shortcut to change the default, 8080, port of the embedded server and serverArguments to pass Meecrowave options to the server. More on that configuration is available at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","this command reads the component jar from the local maven repository so ensure to install the artifact before using it.","The Mojo generate (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration):","For this command to work you will need to just register the plugin:","Component ARchive (.car) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested maven repository containing the component and its depenencies.","It will create a .car in your build directory which is shareable on Talend platforms.","Note that this CAR is executable and exposes the command studio-deploy which takes as parameter a Talend Studio home location. Executed it will install the dependencies into the studio and register the component in your instance. Here is a sample launch command:","gradle-talend-component intends to help you to write components validating components match best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file the SDK uses to build the component classpath. For more information on the configuration you can check out the maven properties matching the attributes.","Here is how to use it:","Recommanded practise for internationalization are:","store messages using ResourceBundle properties file in your component module","the location of the properties are in the same package than the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties)","for your own messages use the internationalization API","Overal idea is to design its messages as methods returning String values and back the template by a ResourceBundle located in the same package than the interface defining these methods and named Messages.","this is the mecanism to use to internationalize your own messages in your own components.","To ensure you internationalization API is identified you need to mark it with @Internationalized:","In some cases you will desire to add some actions unrelated to the runtime. A simple example is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: does my database is up?.","To do so you need to define an @Action which is a method with a name (representing the event name) in a class decorated with @Service:","services are singleton so if you need some thread safety ensure they match that requirement. They shouldn’t store any state too (state is held by the component) since they can be serialized any time.","services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample with a service used to access files:","service is passed to constructor automatically, it can be used as a bean. Only call of service’s method is required.","Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks for instance. Here is the list of all actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Structure.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","The framework provides some built-in services you can inject by type in components and actions out of the box.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data which don’t need to be recomputed very often. Commonly used by actions for the UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","it assumes the dependency is locally available to the execution instance which is not guaranteed yet by the framework.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration which can be used during the design.","it is not recommanded to use it for the runtime since the local configuration is generally different and the instances are distincts.","you can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","This let you define an http client in a declarative manner using an annotated interface.","See the HttpClient usage for details.","Let assume that we have a REST API defined like below, and that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","with a json playload to be created {\"id\":\"some id\", \"data\":\"some data\"}","To create an http client able to consume this REST API, we will define an interface that extends HttpClient,","The HttpClient interface lets you set the base for the http address that our client will hit.","The base is the part of the address that we will need to add to the request path to hit the api.","Every method annotated with @Request of our interface will define an http request. Also every request can have @Codec that let us encode/decode the request/response playloads.","if your payload(s) is(are) String or Void you can ignore the coder/decoder.","The interface should extends HttpClient.","In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with @Service or @Internationalized into the constructor. The i18n services can be useful to have i18n messages for errors handling for example.","This interface can be injected into our Components classes or Services to consume the defined api.","Note: by default /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases you can customize the Connection directly using @UseConfigurer on the method. It will call your custom instance of Configurer. Note that you can use some @ConfigurerOption in the method signature to pass some configurer configuration.","For instance if you have this configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:","For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework on services.","An interceptor defines an annotation marked with @Intercepts which defines the implementation of the interceptor (an InterceptorHandler).","Here is an example:","Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be a BiFunction<Method, Object[], Object> which representes the invocation chain if your interceptor can be used with others.","if you do a generic interceptor it is important to pass the invoker as first parameter. If you don’t do so you can’t combine interceptors at all.","Here is an interceptor implementation for our @Logged API:","This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.","the findAnnotation annotation - inherited from InterceptorHandler is an utility method to find an annotation on a method or class (in this order).","The Job builder let you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, so you can built complex pipelines.","Let’s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write the result to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by an unique id and an URI that identify the component.","The URI follow the form : [family]://[component][?version][&configuration]","family: the name of the component family","component: the name of the component","version : the version of the component, it’s represented in a key=value format. where the key is __version and the value is a number.","configuration: here you can provide the component configuration as key=value tuple where the key is the path of the configuration and the value is the configuration value in string format.","configuration parameters must be URI/URL encoded.","Here is a more concrete job example:","It has some starting components (component that don’t have a from connection and that need to be of type producer).","There is no cyclic connections. as the job pipeline need to be an acyclic graph.","All the components used in connections are already declared.","The connection is used only once. you can’t connect a component input/output branch twice.","In this version, the execution of the job is linear. the component are not executed in parallel even if some steps may be independents.","Depending the configuration you can select which environment you execute your job in.","To select the environment the logic is the following one:","if an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder is passed through the job properties then use it (supported type are a ExecutionBuilder instance, a Class or a String).","if an ExecutionBuilder SPI is present then use it (it is the case if component-runtime-beam is present in your classpath).","else just use a local/standalone execution.","In the case of a Beam execution you can customize the pipeline options using system properties. They have to be prefixed by talend.beam.job.. For instance to set appName option you will set -Dtalend.beam.job.appName=mytest.","The job builder let you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job","If the incoming data has different ids you can provide a complex global key provider relaying on the context that give you the component id and the branch Name.","For beam case, you need to rely on beam pipeline definition and use component-runtime-beam dependency which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and integrate it in the pipeline.","The multiple inputs/outputs are represented by a Map element in beam case to avoid to use multiple inputs/outputs.","you can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, so a kind of Map<String, List<?>>, but materialized as a JsonObject. Input data must be of type JsonObject in this case.","Beam serializing components it is crucial to add component-runtime-standalone dependency to the project. It will take care of providing an implicit and lazy ComponentManager managing the component in a fatjar case.","For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your PTransform with @PartitionMapper or @Processor.","The limitation are:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and just register on the input PCollection a DoFn.","More information on that topic on How to wrap a Beam I/O page.","It is possible to extend the Component API for custom front features.","What is important here is to keep in mind you should do it only if it targets not portable components (only used by the Studio or Beam).","In term of organization it is recommanded to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI just add an annotation which can be put on @Option fields which is decorated with @Ui. All its members will be put in the metadata of the parameter. Example:","this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature.","component-runtime-junit is a small test library allowing you to validate simple logic based on Talend Component tooling.","To import it add to your project the following dependency:","This dependency also provide some mocked components that you can use with your own component to create tests.","The mocked components are provided under the family test :","emitter : a mock of an input component","collector : a mock of an output component","Then you can define a standard JUnit test and use the SimpleComponentRule rule:","The JUnit 5 integration is mainly the same as for JUnit 4 except it uses the new JUnit 5 extension mecanism.","The entry point is the @WithComponents annotation you put on your test class which takes the component package you want to test and you can use @Injected to inject in a test class field an instance of ComponentsHandler which exposes the same utilities than the JUnit 4 rule:","if it is the first time you use JUnit 5, don’t forget the imports changed and you must use org.junit.jupiter.api.Test instead of org.junit.Test. Some IDE versions and surefire versions can also need you to install either a plugin or a specific configuration.","Using the component \"test\"/\"collector\" as in previous sample stores all records emitted by the chain (typically your source) in memory, you can then access them using theSimpleComponentRule.getCollectoedRecord(type). Note that this method filters by type, if you don’t care of the type just use Object.class.","The input mocking is symmetric to the output but here you provide the data you want to inject:","The component configuration is a POJO (using @Option on fields) and the runtime configuration (ExecutionChainBuilder) uses a Map<String, String>. To make the conversion easier, the JUnit integration provides a SimpleFactory.configurationByExample utility to get this map instance from a configuration instance.","Example:","The same factory provides a fluent DSL to create configuration calling configurationByExample without any parameter. The advantage is to be able to convert an object as a Map<String, String> as seen previously or as a query string to use it with the Job DSL:","It handles the encoding of the URI to ensure it is correctly done.","The SimpleComponentRule also allows to test a mapper unitarly, you can get an instance from a configuration and you can execute this instance to collect the output. Here is a snippet doing that:","As for the mapper a processor is testable unitary. The case is a bit more complex since you can have multiple inputs and outputs:","Here again the rule allows you to instantiate a Processor from your code and then to collect the output from the inputs you pass in. There are two convenient implementation of the input factory:","MainInputFactory for processors using only the default input.","JoinInputfactory for processors using multiple inputs have a method withInput(branch, data) The first arg is the branch name and the second arg is the data used by the branch.","you can also implement your own input representation if needed implementing org.talend.sdk.component.junit.ControllableInputFactory.","The folowing artifact will allow you to test against a spark cluster:","The usage relies on a JUnit TestRule. It is recommanded to use it as a @ClassRule to ensure a single instance of a spark cluster is built but you can also use it as a simple @Rule which means it will be created per method instead of per test class.","It takes as parameter the spark and scala version to use. It will then fork a master and N slaves. Finally it will give you submit* method allowing you to send jobs either from the test classpath or from a shade if you run it as an integration test.","Here is a sample:","this is working with @Parameterized so you can submit a bunch of jobs with different args and even combine it with beam TestPipeline if you make it transient!","The integration with JUnit 5 of that spark cluster logic uses @WithSpark marker for the extension and let you, optionally, inject through @SparkInject, the BaseSpark<?> handler to access te spark cluster meta information - like its host/port.","Here is a basic test using it:","In current state, SparkClusterRule doesn’t allow to know a job execution is done - even if it exposes the webui url so you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.","awaitability or equivalent library can help you to write such logic.","Here are the coordinates of the artifact:","And here is how to wait a file exists and its content (for instance) is the expected one:","The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:","this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier shaded to the dependency and the two dependencies are shaded avoiding the conflicts with your component.","It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.","You can plug your own ResponseLocator to map a request to a response but the default implementation - which should be sufficient in most cases - will look in talend/testing/http/<class name>_<method name>.json. Note that you can also put it in talend/testing/http/<request path>.json.","JUnit 4 setup is done through two rules: JUnit4HttpApi which is responsible to start the server and JUnit4HttpApiPerMethodConfigurator which is responsible to configure the server per test and also handle the capture mode (see later).","if you don’t use the JUnit4HttpApiPerMethodConfigurator, the capture feature will be deactivated and the per test mocking will not be available.","Most of the test will look like:","For tests using SSL based services, you will need to use activeSsl() on the JUnit4HttpApi rule.","If you need to access the server ssl socket factory you can do it from the HttpApiHandler (the rule):","JUnit 5 uses a JUnit 5 extension based on the HttpApi annotation you can put on your test class. You can inject the test handler (which has some utilities for advanced cases) through @HttpApiInject:","the injection is optional and the @HttpApi allows you to configure several behaviors of the test.","For tests using SSL based services, you will need to use @HttpApi(useSsl = true).","You can access the client SSL socket factory through the api handler:","The strength of this implementation is to run a small proxy server and auto configure the JVM: http[s].proxyHost, http[s].proxyPort, HttpsURLConnection#defaultSSLSocketFactory and SSLContext#default are auto configured to work out of the box with the proxy.","It allows you to keep in your tests the native and real URLs. For instance this test is perfectlt valid:","If you execute this test, it will fail with a HTTP 400 because the proxy doesn’t find the mocked response. You can create it manually as seen in the introduction of the module but you can also set the property talend.junit.http.capture to the folder where to store the captures. It must be the root folder and not the folder where the json are (ie not prefixed by talend/testing/http by default).","Generally you will want to use src/test/resources. If new File(\"src/test/resources\") resolves to the valid folder when executing your test (Maven default), then you can just set the system property to true, otherwise you need to adjust accordingly the system property value.","Once you ran the tests with this system property, the testing framework will have created the correct mock response files and you can remove the system property. The test will still pass, using google.com…even if you disconnect your machine from the internet.","The rule (extension) is doing all the work for you :).","Setting talend.junit.http.passthrough system property to true, the server will just be a proxy and will execute each request to the actual server - like in capturing mode.","If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details.","JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job","If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details.","Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Talend Component Documentation Overview","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-overview.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Documentation Overview","In this article"],"lvl1":["Getting help","First steps","Learning about Talend Component features"],"text":["Talend Component framework is under the responsability of Mike Hirt team.","If you know nothing about Talend Components, the getting started is the place to start with.","From scratch: Overview | Requirements","Tutorial: Code | Run","Core features: Overview","Advanced: Testing"]},{"lang":"en","title":"Talend Component Getting Started","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/getting-started.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Getting Started","In this article"],"lvl1":["Introducing Talend Component","Talend Component System Requirement","Quick Start"],"text":["Talend Component intends to simplify the development of connectors at two main levels:","how to inject the specific component code into a job or pipeline. It should unify as much as possible the code required to run in DI and BEAM environments.","unify the code required to be able to render in a browser (web) or the eclipse based Studio (SWT).","Talend Component requires Java 8. You can download it on Oracle website.","To develop a component or the project itself it is recommanded to use Apache Maven 3.5.0. you can download it on Apache Maven website.","Generate a component","Create an input component","Create an output component","Test your components","Configuration and sensitive data","Create components for REST API","How to test a REST API","Dev vs CI setup"]},{"lang":"en","title":"Talend Component Javadocs","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/apidocs.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Javadocs","In this article"],"text":["API Documentation","JUnit API Documentation","HTTP JUnit API Documentation"]},{"lang":"en","title":"Talend Component Kit Changelog","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/changelog.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Kit Changelog","In this article"],"lvl1":["Version 0.0.2"],"lvl2":["Bug","Work Item"],"text":["TCOMP-725: MavenDecrypter doesn’t support comments in settings.xml","TCOMP-726: When a component is not found the error message can be misleading","TCOMP-728: Http client doesn’t ignore empty query parameters","TCOMP-722: WebSocket connection fails with a NPE when the endpoint doesn’t exists","TCOMP-723: Adding configurationByExample utility to create query string for Job DSL","TCOMP-724: Documentation endpoint doesn’t support HTML"]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-dev-vs-ci-setup.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["In this article"],"lvl1":["Credentials setup","Let’s adapt our unit test to use the credentials from maven servers","Set up CI server in passthrough mode"],"text":["Development vs Continuous integration Setup","In a previous tutorial, we have shown how to create a mocked test for our Zendesk search component.","In the test you can notice that we have used our Zendesk credentials directly into the code to do a first capture of the API response, then we have switched to a fake credentials in simulation mode as we do not call the real API anymore.","But what if you want to continue to call the real API on the CI server or on a a specific environment ?","Let’s make our test able to get the credentials depending on the execution mode (simulation/passthrough).","This instructions, need to be done, on the CI server or on any environment that require the real credentials.","We will use Maven servers, that support password encryption as a credentials provider, and the test rule MavenDecrypterRule provided by the framework.","This rule let you get credentials from maven settings using a server id.","So let’s create an encrypted server credential for our zendesk instance.","Create a master password using the command : mvn --encrypt-master-password <password>","Store this master password in settings-security.xml file in ~/.m2 folder.","Encrypt zendesk instance password using the command: mvn --encrypt-password <zendesk-password>","Create a server entry under servers in maven settings.xml file in ~/.m2.","Encryption is optional but recommended.","If you want to store the settings-security.xml and settings.xml files elsewhere that the default location ~/.m2. You can do it by setting the path of the directory containing the files into the environment variable talend.maven.decrypter.m2.location","We start by adding MavenDecrypterRule rule to our test class. This rule will let us inject server information stored in maven settings.xml to our test. The rule will also decrypt the password if they are encrypted.","Now we can inject our Zendesk server to our test. For that we add a new field to our class annotated by @DecryptedServer annotation that will holde the server id to be injected.","The MavenDecrypterRule will be able at runtime to inject the server instance into this class. the server instance contains the username and de decrypted password.","Now we can use the server instance in our test to get the real credential in a secured manner.","Here is the complete test class after modification :","This test will continue to work in simulation mode. as we have our API simulation proxy activated.","Let’s make it work in real mode on a CI server. we will use jenkins in this tutorial","Log in to your jenkins then : Click on New Item to create a new build job","Enter an Item name (Job name) and choose the freestyle job. Then click OK.","In Source Code Management section enter your project repository URL. We are using our github repository in this tutorial. We will build the master branch","In the Build Section click on add build step, then choose Invoke top-level Maven targets","Choose you Maven version, and enter your maven build command. we are using a simple clean install and click save.","You can notice that we have added the option -Dtalend.junit.http.passthrough=true to our build command. This Option will tell the API simulation proxy to run in passthrough mode. So it’s will forward all the http request that we have maded in our test to the real API server.","We also get the real credentials, thanks to our MavenDecrypterRule rule.","You can configure the passthrough mode globally on your CI server by setting the environment variable talend.junit.http.passthrough to true.","6.Test the job. click Build now you can notice that your job have built correctly.","That’s all you need to do, now your tests run in a simulation mode on dev and in a (passthrough) mode on your CI server."]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-spark.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["In this article"],"lvl1":["component-runtime-testing-spark"],"lvl2":["JUnit 4","JUnit 5","How to know the job is done"],"text":["The folowing artifact will allow you to test against a spark cluster:","The usage relies on a JUnit TestRule. It is recommanded to use it as a @ClassRule to ensure a single instance of a spark cluster is built but you can also use it as a simple @Rule which means it will be created per method instead of per test class.","It takes as parameter the spark and scala version to use. It will then fork a master and N slaves. Finally it will give you submit* method allowing you to send jobs either from the test classpath or from a shade if you run it as an integration test.","Here is a sample:","this is working with @Parameterized so you can submit a bunch of jobs with different args and even combine it with beam TestPipeline if you make it transient!","The integration with JUnit 5 of that spark cluster logic uses @WithSpark marker for the extension and let you, optionally, inject through @SparkInject, the BaseSpark<?> handler to access te spark cluster meta information - like its host/port.","Here is a basic test using it:","In current state, SparkClusterRule doesn’t allow to know a job execution is done - even if it exposes the webui url so you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.","awaitability or equivalent library can help you to write such logic.","Here are the coordinates of the artifact:","And here is how to wait a file exists and its content (for instance) is the expected one:"]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-junit.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["In this article"],"lvl1":["component-runtime-junit"],"lvl2":["JUnit 4","JUnit 5","Mocking the output","Mocking the input","Creating runtime configuration from component configuration","Testing a Mapper","Testing a Processor"],"text":["component-runtime-junit is a small test library allowing you to validate simple logic based on Talend Component tooling.","To import it add to your project the following dependency:","This dependency also provide some mocked components that you can use with your own component to create tests.","The mocked components are provided under the family test :","emitter : a mock of an input component","collector : a mock of an output component","Then you can define a standard JUnit test and use the SimpleComponentRule rule:","The JUnit 5 integration is mainly the same as for JUnit 4 except it uses the new JUnit 5 extension mecanism.","The entry point is the @WithComponents annotation you put on your test class which takes the component package you want to test and you can use @Injected to inject in a test class field an instance of ComponentsHandler which exposes the same utilities than the JUnit 4 rule:","if it is the first time you use JUnit 5, don’t forget the imports changed and you must use org.junit.jupiter.api.Test instead of org.junit.Test. Some IDE versions and surefire versions can also need you to install either a plugin or a specific configuration.","Using the component \"test\"/\"collector\" as in previous sample stores all records emitted by the chain (typically your source) in memory, you can then access them using theSimpleComponentRule.getCollectoedRecord(type). Note that this method filters by type, if you don’t care of the type just use Object.class.","The input mocking is symmetric to the output but here you provide the data you want to inject:","The component configuration is a POJO (using @Option on fields) and the runtime configuration (ExecutionChainBuilder) uses a Map<String, String>. To make the conversion easier, the JUnit integration provides a SimpleFactory.configurationByExample utility to get this map instance from a configuration instance.","Example:","The same factory provides a fluent DSL to create configuration calling configurationByExample without any parameter. The advantage is to be able to convert an object as a Map<String, String> as seen previously or as a query string to use it with the Job DSL:","It handles the encoding of the URI to ensure it is correctly done.","The SimpleComponentRule also allows to test a mapper unitarly, you can get an instance from a configuration and you can execute this instance to collect the output. Here is a snippet doing that:","As for the mapper a processor is testable unitary. The case is a bit more complex since you can have multiple inputs and outputs:","Here again the rule allows you to instantiate a Processor from your code and then to collect the output from the inputs you pass in. There are two convenient implementation of the input factory:","MainInputFactory for processors using only the default input.","JoinInputfactory for processors using multiple inputs have a method withInput(branch, data) The first arg is the branch name and the second arg is the data used by the branch.","you can also implement your own input representation if needed implementing org.talend.sdk.component.junit.ControllableInputFactory."]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-http.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["In this article"],"lvl1":["component-runtime-http-junit"],"lvl2":["JUnit 4","JUnit 5","Capturing mode","Passthrough mode"],"lvl3":["SSL","SSL"],"text":["The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:","this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier shaded to the dependency and the two dependencies are shaded avoiding the conflicts with your component.","It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.","You can plug your own ResponseLocator to map a request to a response but the default implementation - which should be sufficient in most cases - will look in talend/testing/http/<class name>_<method name>.json. Note that you can also put it in talend/testing/http/<request path>.json.","JUnit 4 setup is done through two rules: JUnit4HttpApi which is responsible to start the server and JUnit4HttpApiPerMethodConfigurator which is responsible to configure the server per test and also handle the capture mode (see later).","if you don’t use the JUnit4HttpApiPerMethodConfigurator, the capture feature will be deactivated and the per test mocking will not be available.","Most of the test will look like:","For tests using SSL based services, you will need to use activeSsl() on the JUnit4HttpApi rule.","If you need to access the server ssl socket factory you can do it from the HttpApiHandler (the rule):","JUnit 5 uses a JUnit 5 extension based on the HttpApi annotation you can put on your test class. You can inject the test handler (which has some utilities for advanced cases) through @HttpApiInject:","the injection is optional and the @HttpApi allows you to configure several behaviors of the test.","For tests using SSL based services, you will need to use @HttpApi(useSsl = true).","You can access the client SSL socket factory through the api handler:","The strength of this implementation is to run a small proxy server and auto configure the JVM: http[s].proxyHost, http[s].proxyPort, HttpsURLConnection#defaultSSLSocketFactory and SSLContext#default are auto configured to work out of the box with the proxy.","It allows you to keep in your tests the native and real URLs. For instance this test is perfectlt valid:","If you execute this test, it will fail with a HTTP 400 because the proxy doesn’t find the mocked response. You can create it manually as seen in the introduction of the module but you can also set the property talend.junit.http.capture to the folder where to store the captures. It must be the root folder and not the folder where the json are (ie not prefixed by talend/testing/http by default).","Generally you will want to use src/test/resources. If new File(\"src/test/resources\") resolves to the valid folder when executing your test (Maven default), then you can just set the system property to true, otherwise you need to adjust accordingly the system property value.","Once you ran the tests with this system property, the testing framework will have created the correct mock response files and you can remove the system property. The test will still pass, using google.com…even if you disconnect your machine from the internet.","The rule (extension) is doing all the work for you :).","Setting talend.junit.http.passthrough system property to true, the server will just be a proxy and will execute each request to the actual server - like in capturing mode."]},{"lang":"en","title":"Talend Component Kit Release Process","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/release-process.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Kit Release Process","Setup","In this article"],"lvl1":["Gpg key","Settings.xml","Clean up JIRA","Do the release","After the release"],"text":["Version: {docversion}","This page gives some hints about how to release the repository.","Before configuring Maven you need to have a GPG key. Once you installed GPG, you can either import an existing key or generate one using gpg --gen-key.","Then a few entries into your maven settings.xml are needed to provide the needed credentials for the release. Here is the overall template:","all the environment variables should be either set in your environment or hardcoded inline. Note that it is more than highly recommanded to use maven encryption: maven.apache.org/guides/mini/guide-encryption.html.","The OSSH variables are your Sonatype OSS repository credential with the permissions to deploy on org.talend. If you don’t have it already you can ask for one at issues.sonatype.org/projects/OSSRH using your talend address.","The GITHUB variables are your Github account credentials. It is mainly used to update the documentation.","The JIRA variables are your Talend account credentials with read permissions on jira.talendforge.org/projects/TCOMP/.","The Blackduck configuration is used for security scans.","The GPG variables reference the key you created in previous part.","The release contacts JIRA to create the release notes. It uses all TCOMP issues which have the label changelog. Before any release don’t forget to go through all issues of the version you will release and add/remove the label depending the issue you want to appear into the release note.","at that stage we assume previous steps have been done.","Then, the release uses a standard Maven process, you should be able to do it in two steps:","Once these commands passed, you need to do/ensure:","The git tag corresponding to the release was pushed upstream (on github.com/Talend/component-runtime), if not, execute git push --follow-tags?","Close and release the staging repository on Sonatype OSS (log in on oss.sonatype.org/, then hit Staging Repositories in the left pane, select your repository and hit Close then Release on the top buttons).","After a moment - it can take a few hours - the binaries will be available on central (repo.apache.maven.org/maven2/). Don’t forget to check it to ensure there was no issue during the release process.","You can also validate that the release deployed the new version (into the version menu) for the website."]},{"lang":"en","title":"Talend Component REST API Documentation","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-rest.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component REST API Documentation","In this article"],"lvl1":["HTTP API","Web forms and REST API","Logging","Server Configuration"],"lvl2":["REST resources of Component Runtime :: Server","Deprecated endpoints","WebSocket transport","Use UiSpec model without all the tooling","Javascript integration"],"lvl3":["POST api/v1/action/execute","GET api/v1/action/index","GET api/v1/component/dependencies","GET api/v1/component/dependency/{id}","GET api/v1/component/details","GET api/v1/component/icon/family/{id}","GET api/v1/component/icon/{id}","GET api/v1/component/index","POST api/v1/component/migrate/{id}/{configurationVersion}","GET api/v1/configurationtype/index","POST api/v1/configurationtype/migrate/{id}/{configurationVersion}","GET api/v1/documentation/component/{id}","GET api/v1/environment","POST api/v1/execution/read/{family}/{component}","POST api/v1/execution/write/{family}/{component}"],"text":["a test environment is available on Heroku and browable using Talend Component Kit Server Restlet Studio instance.","The HTTP API intends to expose over HTTP most of Talend Component features, it is a standalone Java HTTP server.","WebSocket protocol is activated for the endpoints as well, instead of /api/v1 they uses the base /websocket/v1, see WebSocket part for more details.","Here is the API:","0.0.3-SNAPSHOT","This endpoint will execute any UI action and serialize the response as a JSON (pojo model) It takes as input the family, type and name of the related action to identify it and its configuration as a flat key value set using the same kind of mapping than for components (option path as key).","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Query Param: action, java.lang.String Query Param: family, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (java.lang.RuntimeException)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","This endpoint returns the list of available actions for a certain falimy and potentially filters the \" output limiting it to some families and types of actions.","No body Query Param: family, java.lang.String Query Param: language, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ActionList)","Returns a list of dependencies for the given components.","don’t forget to add the component itself since it will not be part of the dependencies.","Then you can use /dependency/{id} to download the binary.","No body Query Param: identifier, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.Dependencies)","Return a binary of the dependency represented by id. It can be maven coordinates for dependencies or a component id.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (javax.ws.rs.core.StreamingOutput)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the set of metadata about a few components identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentDetailList)","Response Body: (java.util.Map<java.lang.String, org.talend.sdk.component.server.front.model.error.ErrorPayload>)","Returns a particular family icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns a particular component icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the list of available components.","No body Query Param: includeIconContent, boolean Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentIndices)","Allows to migrate a component configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns all available configuration type - storable models.","No body Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Allows to migrate a configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns an asciidoctor version of the documentation for the component represented by its identifier id.","Format can be either asciidoc or html - if not it will fallback on asciidoc - and if html is selected you get a partial document.","it is recommanded to use asciidoc format and handle the conversion on your side if you can, the html flavor handdles a limited set of the asciidoc syntax only like plain arrays, paragraph and titles.","The documentation will likely be the family documentation but you can use anchors to access a particular component (_componentname_inlowercase).","No body Path Param: id, java.lang.String Query Param: format, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.DocumentationContent)","Returns the environment of this instance. Useful to check the version or configure a healthcheck for the server.","No body","Content-Type: */*","Response Body: (org.talend.sdk.component.server.front.model.Environment)","deprecated","Read inputs from an instance of mapper. The number of returned records if enforced to be limited to 1000. The format is a JSON based format where each like is a json record.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: size, long","Content-Type: talend/stream","deprecated","Sends records using a processor instance. Note that the processor should have only an input. Behavior for other processors is undefined. The input format is a JSON based format where each like is a json record - same as for the symmetric endpoint.","Content-Type: talend/stream Request Body: (java.io.InputStream) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: group-size, long","Content-Type: application/json","to ensure the migration can be activated you need to set in the execution configuration you send to the server the version it was created with (component version, it is in component detail endpoint) with the key tcomp::component::version.","If some endpoints are intended to disappear they will be deprecated. In practise it means a header X-Talend-Warning will be returned with some message as value.","You can connect on any endpoint replacing /api by /websocket and appending /<http method> for the URL and formatting the request as:","For instance:","The response is formatted as follow:","if you have a doubt about the endpoint, they are all logged during startup and you can find them in the logs.","If you don’t want to create a pool of connection per endpoint/verb you can use the bus endpoint: /websocket/v1/bus. This endpoint requires that you add the header destinationMethod to each request with the verb value - default would be GET:","component-form library provides a way to build a component REST API facade compatible with react form library.","A trivial facade can be:","the Client can be created using ClientFactory.createDefault(System.getProperty(\"app.components.base\", \"http://localhost:8080/api/v1\")) and the service can be a simple new UiSpecService().","All the conversion between component model (REST API) and uiSpec model is done through the UiSpecService. It is based on the object model which will be mapped to a ui model. The advantage to have a flat model in the component REST API is to make these layers easy to customize.","You can completely control the available components, tune the rendering switching the uiSchema if desired or add/remove part of the form. You can also add custom actions/buttons for specific needs of the application.","the /migrate endpoint has nothing special so was not shown in previous snippet but if you need it you must add it as well.","This maven dependency provides the UISpec model classes. You can use the Ui API (with or without the builders) to create UiSpec representations.","Example:","We extract the JsonSchema from reflection on the class Form1. Note that @JsonSchemaIgnore allows to ignore a field and @JsonSchemaProperty allows to rename a property,","We build programmatically using the builder API a UiSchema,","We pass an instance of the form to let the serializer extracts it JSON model,","We serialize the Ui model which can be used by UiSpec compatible front widgets.","the model uses JSON-B API to define the binding, ensure to have an implementation in your classpath. This can be done adding these dependencies:","Default javascript integration goes through Talend UI Forms library.","It is bundled as a NPM module called component-kit.js. It provides a default trigger implementation for the UIForm.","Here is how to use it:","The logging uses Log4j2, you can specify a custom configuration using the system property -Dlog4j.configurationFile or adding a log4j2.xml file into the classpath.","Here are some common configurations:","Console logging:","This outputs messages looking like:","JSON logging:","Output messages look like:","Rolling file appender","More details are available on RollingFileAppender documentation.","of course you can compose previous layout (message format) and appenders (where logs are written).","The server module contains several configuration you can set in:","Environment variables","System properties","A file located based on the --component-configuration CLI option","the configuration is read from system properties, environment variables, ….","Key","Description","Default","talend.component.server.component.coordinates","A comma separated list of gav to locate the components","-","talend.component.server.component.registry","A property file where the value is a gav of a component to register (complementary with coordinates)","-","talend.component.server.documentation.active","Should the /documentation endpoint be activated.","true","talend.component.server.execution.dataset.retriever.timeout","How long the read execution endpoint can last (max)","180","talend.component.server.execution.pool.size","The size of the execution pool for runtime endpoints.","64","talend.component.server.execution.pool.wait","How long the application waits during shutdown for the execution tasks to complete","PT10S","talend.component.server.jaxrs.exceptionhandler.defaultMessage","If set it will replace any message for exceptions. Set to false to use the actual exception message.","false","talend.component.server.maven.repository","The local maven repository used to locate components and their dependencies","${user.home}/.m2/repository","talend.component.server.monitoring.brave.reporter.async","When using url or kafka reporter, you can configure the async reporter with properties passed to this configuration entry.Ex: messageTimeout=5000,closeTimeout=5000.","console","talend.component.server.monitoring.brave.reporter.type","The brave reporter to use to send the spans. Supported values are [auto, console, noop, url]. When configuration is needed,you can use this syntax to configure the repoter if needed: <name>(config1=value1, config2=value2), for example: url(endpoint=http://brave.company.com.","In auto mode, if environment variable TRACING_ON doesn’t exist or is set to false, noop will be selected, and is set to true, TRACING_KAFKA_URL, TRACING_KAFKA_TOPIC and TRACING_SAMPLING_RATE will configure kafka reporter..","auto","talend.component.server.monitoring.brave.sampling.action.rate","The accuracy rate of the sampling for action endpoints.","-1","talend.component.server.monitoring.brave.sampling.component.rate","The accuracy rate of the sampling for component endpoints.","-1","talend.component.server.monitoring.brave.sampling.configurationtype.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.documentation.rate","The accuracy rate of the sampling for documentation endpoint.","-1","talend.component.server.monitoring.brave.sampling.environment.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.execution.rate","The accuracy rate of the sampling for execution endpoints.","1","talend.component.server.monitoring.brave.sampling.rate","The accuracy rate of the sampling.","-1.","talend.component.server.monitoring.brave.service.name","The name used by the brave integration (zipkin)","component-server","talend.component.server.security.command.handler","How to validate a command/request. Accepted values: securityNoopHandler.","securityNoopHandler","talend.component.server.security.connection.handler","How to validate a connection. Accepted values: securityNoopHandler.","securityNoopHandler"]},{"lang":"en","title":"Talend Component Studio Integration","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/studio.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Studio Integration","In this article"],"lvl1":["Design","Installation","Configuration"],"lvl2":["Random port when running concurrent studio instances"],"text":["The studio integration relies on Component Server (see Web for more details).","When the plugin is deployed it starts a local server the Studio uses to gather data about the components.","Copy org.talend.sdk.component.studio-integration.jar in the $STUDIO_HOME/plugins directory and restart the studio.","Also ensure the component-server dependencies and commons-cli 1.4 are into the Studio maven repository. If you install any component, ensure its dependencies are in the repository as well.","you can set in $STUDIO_HOME/configuration/config.ini the value maven.repository to global to reuse your local maven repository.","The configuration goes into $STUDIO_HOME/configuration/config.ini.","Name","Description","Default","component.debounce.timeout","Specifies timeout in milliseconds before calling listeners in components Text fields","750","component.kit.skip","If true the plugin is not active. Useful if you don’t have any component develop with the framework.","false","component.java.arguments","Component server additional options","-","component.java.m2","The maven repository the server uses to resolve components","default to global Studio configuration","component.java.coordinates","A list of comma separated GAV (groupId:artifactId:version) of components to register","-","component.java.registry","A properties file with values matching component GAV (groupId:artifactId:version) which are registered at startup","-","component.java.port","Set a port to use for the server","random","components.server.beam.active","Active, if set to true, beam support (Experimental). It requires beam sdk java core dependencies to be available.","false","component.server.jul.forceConsole","Adds a console handler to JUL to see logs in the console. This can be helpful in dev since the formatting will be better than the OSGi one in workspace/.metadata/.log.","it uses java.util.logging.SimpleFormatter.format property to define its format. Default is %1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n but for development purposes [%4$s] %5$s%6$s%n is simpler and more readable.","false","to activate the plugin and be able to deploy your component, don’t forget to set component.kit.skip to true.","A common developer configuration/config.ini will use the following specific entries:","If you run multiple Studio instance automatically in parallel you can have some issues with the random port computation (can happen on a CI platform). For that purpose you can create the file $HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock.","When a server will start it will acquire a lock on that file and prevent another one to get a port until it is started. It ensures you can’t get two concurrent processes getting the same allocated port.","it is highly unlikely it happens on a desktop and forcing a different value through component.java.port in your config.ini is likely a better solution for local installations."]},{"lang":"en","title":"Talend Component Testing Documentation","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-testing.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Component Testing Documentation","In this article"],"lvl1":["Best practises","component-runtime-testing","Beam testing","Multiple environments for the same tests","Secrets/Passwords and Maven","Generating data?"],"lvl2":["Parameterized tests","component-runtime-junit","component-runtime-testing-spark","component-runtime-http-junit","JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl3":["JUnit 4","JUnit 5","JUnit 4","JUnit 5","Mocking the output","Mocking the input","Creating runtime configuration from component configuration","Testing a Mapper","Testing a Processor","JUnit 4","JUnit 5","How to know the job is done","JUnit 4","JUnit 5","Capturing mode","Passthrough mode","Advanced usage"],"text":["this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature.","component-runtime-junit is a small test library allowing you to validate simple logic based on Talend Component tooling.","To import it add to your project the following dependency:","This dependency also provide some mocked components that you can use with your own component to create tests.","The mocked components are provided under the family test :","emitter : a mock of an input component","collector : a mock of an output component","Then you can define a standard JUnit test and use the SimpleComponentRule rule:","The JUnit 5 integration is mainly the same as for JUnit 4 except it uses the new JUnit 5 extension mecanism.","The entry point is the @WithComponents annotation you put on your test class which takes the component package you want to test and you can use @Injected to inject in a test class field an instance of ComponentsHandler which exposes the same utilities than the JUnit 4 rule:","if it is the first time you use JUnit 5, don’t forget the imports changed and you must use org.junit.jupiter.api.Test instead of org.junit.Test. Some IDE versions and surefire versions can also need you to install either a plugin or a specific configuration.","Using the component \"test\"/\"collector\" as in previous sample stores all records emitted by the chain (typically your source) in memory, you can then access them using theSimpleComponentRule.getCollectoedRecord(type). Note that this method filters by type, if you don’t care of the type just use Object.class.","The input mocking is symmetric to the output but here you provide the data you want to inject:","The component configuration is a POJO (using @Option on fields) and the runtime configuration (ExecutionChainBuilder) uses a Map<String, String>. To make the conversion easier, the JUnit integration provides a SimpleFactory.configurationByExample utility to get this map instance from a configuration instance.","Example:","The same factory provides a fluent DSL to create configuration calling configurationByExample without any parameter. The advantage is to be able to convert an object as a Map<String, String> as seen previously or as a query string to use it with the Job DSL:","It handles the encoding of the URI to ensure it is correctly done.","The SimpleComponentRule also allows to test a mapper unitarly, you can get an instance from a configuration and you can execute this instance to collect the output. Here is a snippet doing that:","As for the mapper a processor is testable unitary. The case is a bit more complex since you can have multiple inputs and outputs:","Here again the rule allows you to instantiate a Processor from your code and then to collect the output from the inputs you pass in. There are two convenient implementation of the input factory:","MainInputFactory for processors using only the default input.","JoinInputfactory for processors using multiple inputs have a method withInput(branch, data) The first arg is the branch name and the second arg is the data used by the branch.","you can also implement your own input representation if needed implementing org.talend.sdk.component.junit.ControllableInputFactory.","The folowing artifact will allow you to test against a spark cluster:","The usage relies on a JUnit TestRule. It is recommanded to use it as a @ClassRule to ensure a single instance of a spark cluster is built but you can also use it as a simple @Rule which means it will be created per method instead of per test class.","It takes as parameter the spark and scala version to use. It will then fork a master and N slaves. Finally it will give you submit* method allowing you to send jobs either from the test classpath or from a shade if you run it as an integration test.","Here is a sample:","this is working with @Parameterized so you can submit a bunch of jobs with different args and even combine it with beam TestPipeline if you make it transient!","The integration with JUnit 5 of that spark cluster logic uses @WithSpark marker for the extension and let you, optionally, inject through @SparkInject, the BaseSpark<?> handler to access te spark cluster meta information - like its host/port.","Here is a basic test using it:","In current state, SparkClusterRule doesn’t allow to know a job execution is done - even if it exposes the webui url so you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.","awaitability or equivalent library can help you to write such logic.","Here are the coordinates of the artifact:","And here is how to wait a file exists and its content (for instance) is the expected one:","The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:","this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier shaded to the dependency and the two dependencies are shaded avoiding the conflicts with your component.","It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.","You can plug your own ResponseLocator to map a request to a response but the default implementation - which should be sufficient in most cases - will look in talend/testing/http/<class name>_<method name>.json. Note that you can also put it in talend/testing/http/<request path>.json.","JUnit 4 setup is done through two rules: JUnit4HttpApi which is responsible to start the server and JUnit4HttpApiPerMethodConfigurator which is responsible to configure the server per test and also handle the capture mode (see later).","if you don’t use the JUnit4HttpApiPerMethodConfigurator, the capture feature will be deactivated and the per test mocking will not be available.","Most of the test will look like:","For tests using SSL based services, you will need to use activeSsl() on the JUnit4HttpApi rule.","If you need to access the server ssl socket factory you can do it from the HttpApiHandler (the rule):","JUnit 5 uses a JUnit 5 extension based on the HttpApi annotation you can put on your test class. You can inject the test handler (which has some utilities for advanced cases) through @HttpApiInject:","the injection is optional and the @HttpApi allows you to configure several behaviors of the test.","For tests using SSL based services, you will need to use @HttpApi(useSsl = true).","You can access the client SSL socket factory through the api handler:","The strength of this implementation is to run a small proxy server and auto configure the JVM: http[s].proxyHost, http[s].proxyPort, HttpsURLConnection#defaultSSLSocketFactory and SSLContext#default are auto configured to work out of the box with the proxy.","It allows you to keep in your tests the native and real URLs. For instance this test is perfectlt valid:","If you execute this test, it will fail with a HTTP 400 because the proxy doesn’t find the mocked response. You can create it manually as seen in the introduction of the module but you can also set the property talend.junit.http.capture to the folder where to store the captures. It must be the root folder and not the folder where the json are (ie not prefixed by talend/testing/http by default).","Generally you will want to use src/test/resources. If new File(\"src/test/resources\") resolves to the valid folder when executing your test (Maven default), then you can just set the system property to true, otherwise you need to adjust accordingly the system property value.","Once you ran the tests with this system property, the testing framework will have created the correct mock response files and you can remove the system property. The test will still pass, using google.com…even if you disconnect your machine from the internet.","The rule (extension) is doing all the work for you :).","Setting talend.junit.http.passthrough system property to true, the server will just be a proxy and will execute each request to the actual server - like in capturing mode.","If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details.","JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job","If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details.","Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Talend Components Definitions Documentation","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/documentation-definition.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Talend Components Definitions Documentation","In this article"],"lvl1":["Components Definition","Configuring components","Gallery","Registering components","Internationalization"],"lvl2":["PartitionMapper","Definition","Producer","Processor","Multiple outputs","Multiple inputs","Output","Combiners?","Primitives","Complex object mapping","Constraints and validation on the configuration/input","Marking a configuration as a particular type of data","Define links between properties","Add hints about the rendering based on configuration/component knowledge","Widgets","Validations","Components metadata","Default components keys"],"lvl3":["@Assessor","@Split","@Emitter","List case","Map case","Management of configuration versions","@PartitionMapper","@Processor"],"text":["Talend Component framework relies on several primitive components.","They can all use @PostConstruct and @PreDestroy to initialize/release some underlying resource at the beginning/end of the processing.","in distributed environments class' constructor will be called on cluster manager node, methods annotated with @PostConstruct and @PreDestroy annotations will be called on worker nodes. Thus, partition plan computation and pipeline task will be performed on different nodes.","","Created task consists of Jar file, containing class, which describes pipeline(flow) which should be processed in cluster.","During partition plan computation step pipeline is analyzed and split into stages. Cluster Manager node instantiates mappers/processors gets estimated data size using mappers, splits created mappers according to the estimated data size. All instances are serialized and sent to Worker nodes afterwards.","Serialized instances are received and deserialized, methods annotated with @PostConstruct annotation are called. After that, pipeline execution is started. Processor’s @BeforeGroup annotated method is called before processing first element in chunk. After processing number of records estimated as chunk size, Processor’s @AfterGroup annotated method called. Chunk size is calculated depending on environment the pipeline is processed by. After pipeline is processed, methods annotated with @PreDestroy annotation are called.","","","all framework managed methods MUST be public too. Private methods are ignored.","in term of design the framework tries to be as declarative as possible but also to stay extensible not using fixed interfaces or method signatures. This will allow to add incrementally new features of the underlying implementations.","A PartitionMapper is a component able to split itself to make the execution more efficient.","This concept is borrowed to big data world and useful only in this context (BEAM executions). Overall idea is to divide the work before executing it to try to reduce the overall execution time.","The process is the following:","Estimate the size of the data you will work on. This part is often heuristic and not very precise.","From that size the execution engine (runner for beam) will request the mapper to split itself in N mappers with a subset of the overall work.","The leaf (final) mappers will be used as a Producer (actual reader) factory.","this kind of component MUST be Serializable to be distributable.","A partition mapper requires 3 methods marked with specific annotations:","@Assessor for the evaluating method","@Split for the dividing method","@Emitter for the Producer factory","The assessor method will return the estimated size of the data related to the component (depending its configuration). It MUST return a Number and MUST not take any parameter.","Here is an example:","The split method will return a collection of partition mappers and can take optionally a @PartitionSize long value which is the requested size of the dataset per sub partition mapper.","Here is an example:","The emitter method MUST not have any parameter and MUST return a producer. It generally uses the partition mapper configuration to instantiate/configure the producer.","Here is an example:","A Producer is the component interacting with a physical source. It produces input data for the processing flow.","A producer is a very simple component which MUST have a @Producer method without any parameter and returning any data:","A Processor is a component responsible to convert an incoming data to another model.","A processor MUST have a method decorated with @ElementListener taking an incoming data and returning the processed data:","this kind of component MUST be Serializable since it is distributed.","if you don’t care much of the type of the parameter and need to access data on a \"map like\" based rule set, then you can use JsonObject as parameter type and Talend Component will just wrap the data to enable you to access it as a map. The parameter type is not enforced, i.e. if you know you will get a SuperCustomDto then you can use that as parameter type but for generic component reusable in any chain it is more than highly encouraged to use JsonObject until you have your an evaluation language based processor (which has its own way to access component). Here is an example:","A processor also supports @BeforeGroup and @AfterGroup which MUST be methods without parameters and returning void (result would be ignored). This is used by the runtime to mark a chunk of the data in a way which is estimated good for the execution flow size.","this is estimated so you don’t have any guarantee on the size of a group. You can literally have groups of size 1.","The common usage is to batch records for performance reasons:","it is a good practise to support a maxBatchSize here and potentially commit before the end of the group in case of a computed size which is way too big for your backend.","In some case you may want to split the output of a processor in two. A common example is \"main\" and \"reject\" branches where part of the incoming data are put in a specific bucket to be processed later.","This can be done using @Output. This can be used as a replacement of the returned value:","Or you can pass it a string which will represent the new branch:","Having multiple inputs is closeto the output case excep it doesn’t require a wrapper OutputEmitter:","@Input takes the input name as parameter, if not set it uses the main (default) input branch.","due to the work required to not use the default branch it is recommanded to use it when possible and not name its branches depending on the component semantic.","An Output is a Processor returning no data.","Conceptually an output is a listener of data. It perfectly matches the concept of processor. Being the last of the execution chain or returning no data will make your processor an output:","For now Talend Component doesn’t enable you to define a Combiner. It would be the symmetric part of the partition mapper and allow to aggregate results in a single one.","Component are configured through their constructor parameters. They can all be marked with @Option which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with -parameter flag to not have arg0, arg1, … as names).","The parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","it is recommanded to use simple models which can be serialized by components to avoid headaches when implementing serialized components.","Here is an example:","Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.","The instantiation of the parameters is done from the properties passed to the component (see next part).","What is considered as a primitive in this mecanism is a class which can be directly converted from a String to the expected type.","It obviously includes all java primitives, String type itself but also all the types with a org.apache.xbean.propertyeditor.Converter.","This includes out of the box:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from properties to object is using the dotted notation. For instance:","will match","assuming the method parameter was configured with @Option(\"file\").","Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named files and the elements are of FileOptions type, here is how to define a list of 2 elements:","Inspired from the list case, the map uses .key[index] and .value[index] to represent its key and values:","don’t abuse of map type. If not needed for your configuration (= if you can configure your component with an object) don’t use it.","It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the validation in org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a java pattern, you can use xregex library in javascript.","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones are the:","datastore: all the data you need to connect to the backend","dataset: a datastore coupled with all the data you need to execute an action","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","the component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.","Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.","For example, we can think about a relational database that support JDBC:","A datastore may provide:","jdbc url, username, password","A dataset may be:","datastore (that will provide the connection data to the database)","table name, data []","The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration into the targeted platforms (studio, web applications…)","The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.","Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.","For example, a configuration type index for the above example will be:","It can be needed to define a binding between properties, a set of annotations allows to do it:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","Target element location is specified as a relative path to current location using Unix path characters. Configuration class delimiter is /. Parent configuration class is specified by ... Thus ../targetProperty denotes a property, which is located in parent configuration class and has name targetProperty.","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration. A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper wants to influence the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first","second,third\",\"ui::gridlayout::value2::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","target support should cover org.talend.core.model.process.EParameterFieldType but we need to ensure web renderers is able to handle the same widgets.","Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Data store validation","As seen in the Getting Started, you need an annotation to register your component through family method. Multiple components can use the same family value but the pair family+name MUST be unique for the system.","If you desire (recommended) to share the same component family name instead of repeating yourself in all family methods, you can use @Components annotation on the root package of you component, it will enable you to define the component family and the categories the component belongs to (default is Misc if not set). Here is a sample package-info.java:","For an existing component it can look like:","Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information. These metadata are set on the component class and belongs to org.talend.sdk.component.api.component package.","API","Description","@Icon","Set an icon key used to represent the component. Note you can use a custom key with custom() method but it is not guaranteed the icon will be rendered properly.","@Version","Set the component version, default to 1.","Example:","If some impacting changes happen on the configuration they can be manage through a migration handler at component level (to enable to support trans-model migration).","The @Version annotation supports a migrationHandler method which will take the implementation migrating the incoming configuration to the current model.","For instance if filepath configuration entry from v1 changed to location in v2 you can remap the value to the right key in your MigrationHandler implementation.","it is recommanded to not manage all migrations in the handler but rather split it in services you inject in the migration handler (through constructor):","What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order you need to ensure they are sorted. Said otherwise: don’t see this API as a migration API but as a migration callback and adjust the migration code structure you need behind the MigrationHandler based on your component requirements. The service injection enables you to do so.","@PartitionMapper will obviously mark a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. Said otherwise it will enforce an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor will be considered as a producer factory:","In the simplest case you should store messages using ResourceBundle properties file in your component module to use internationalization. The location of the properties file should be in the same package as the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties).","Out of the box components are internationalized using the same location logic for the resource bundle and here is the list of supported keys:","Name Pattern","Description","${family}._displayName","the display name of the family","${family}.${configurationType}.${name}._displayName","the display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","the display name of the component (used by the GUIs)","${property_path}._displayName","the display name of the option.","${simple_class_name}.${property_name}._displayName","the display name of the option using it class name.","${property_path}._placeholder","the placeholder of the option.","Example of configuration for a component named list belonging to the family memory (@Emitter(family = \"memory\", name = \"list\")):","Configuration class are also translatable using the simple class name in the messages properties file. This useful when you have some common configuration shared within multiple components.","If you have a configuration class like :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.","If you have a display name using the property path, it will override the display name defined using the simple class name. this rule apply also to placeholders"]},{"lang":"en","title":"Test your components","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-test-your-components.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Test your components","In this article"],"text":["In a previous tutorial we have created an input component for hazelcast. In this one we will show how to write some unit tests for it.","In this tutorial we will cover :","How to load components in a unit test.","How to create a job pipeline.","How to run the test in standalone mode.","Here is our test class. let’s examine it in details."]},{"lang":"en","title":"Wall of Fame","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/contributors.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Wall of Fame"],"lvl2":["Romain Manni-Bucau","#859 commits","Ivan Gonchar","#188 commits","Anas KHABALI","#159 commits","Chao MENG","#21 commits","Jimmy Somsanith","#9 commits","ypiel","#1 commit"],"text":["Joined the Apache EE family (TomEE, Johnzon, BatchEE...) in 2011. My goal is to make development a detail of an idea becoming reality. Blog: https://rmannibucau.metawerx.net","","I am a software developer at @Talend For my personal projects you can check them @khabali Blog: https://khabali.github.io","R&D","Java and Javascript developer",""]},{"lang":"en","title":"Wrapping a Beam I/O","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/wrapping-a-beam-io.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Wrapping a Beam I/O","In this article"],"lvl1":["Limitations","Wrap an input","Wrap an output","Tip","Advanced"],"lvl2":["Coder","Sample"],"text":["This part is limited to particular kinds of Beam PTransform:","the PTransform<PBegin, PCollection<?>> for the inputs","the PTransform<PCollection<?>, PDone> for the outputs. The outputs also must use a single (composite or not) DoFn in their apply method.","Assume you want to wrap an input like this one (based on existing Beam ones):","To wrap the Read in a framework component you create a transform delegating to this one with a @PartitionMapper annotation at least (you likely want to follow the best practices as well adding @Icon and @Version) and using @Option constructor injections to configure the component:","Assume you want to wrap an output like this one (based on existing Beam ones):","You can wrap this output exactly the same way than for the inputs but using @Processor this time:","Note that the class org.talend.sdk.component.runtime.beam.transform.DelegatingTransform fully delegates to another transform the \"expansion\". Therefore you can extend it and just implement the configuration mapping:","In terms of classloading, when you write an IO all the Beam SDK Java core stack is assumed in Talend Component Kit runtime as provided so never include it in compile scope - it would be ignored anyway.","If you need a JSonCoder you can use org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory service which gives you access the JSON-P and JSON-B coders.","Here is a sample input based on beam Kafka:","Since the Beam wrapper doesn’t respect the standard Kit programming Model (no @Emitter for instance) you need to set <talend.validation.component>false</talend.validation.component> property in your pom.xml (or equivalent for Gradle) to skip the Kit component programming model validations."]},{"lang":"en","title":"Write an Output component","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/tutorial-create-an-output-component.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["Write an Output component","In this article"],"lvl1":["The component configuration","The Output"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The ElementListener method","The full implementation of the Output"],"text":["In this tutorial we will create a complete working output component for hazelcast. This will include :","The component configuration and the UI layout","The output that is responsible for connecting and writing data to the data source.","How to create component configuration has already been described in \"Create an input component\" tutorial. For now we will use the same component configuration. We will only add a couple of fields required for our output component to already described configuration.","We will need those fields to determine key and value attributes for our Hazelcast map.","As our output component needs to work in distributed environments it should implement Serializable interface.","Let’s take a look at the skeleton of our output component.","in real implementation you can desire to bulk write the updates accordingly to groups, see Processor description","Let’s implement all methods required for our output.","We will need Hazelcast instance and Hazelcast map. We add those as attributes to the output. <1> Here we create an instance of hazelcast according to the provided configuration. Here you can notice that we use the injected HazelcastService instance to perform that. This service is implemented in the project. See the implementation in \"Create an input component\" tutorial. <2> We get the Hazelcast map according to the map name from configuration. We use Hazelcast instance for that purpose.","in production you will not want to create one instance per thread/worker but we will cover that in another coming tutorial","We shutdown the instance that we have created in the PostConstruct and we free the Hazelcast map reference.","Here is the full code source for the output to have a global view of it. Read more about output…","We have seen how to create a complete working output in this tutorial. Later we will explain how to create some unit tests for it."]},{"lang":"en","title":"component-runtime-testing","version":"0.0.3","url":"https://talend.github.io/component-runtime/main/0.0.3/testing-runtime.html","date":"2018-08-31T15:59:01Z","timestamp":1535731141754,"lvl0":["component-runtime-testing","In this article"],"lvl1":["component-runtime-testing-spark"],"lvl2":["JUnit 4","JUnit 5","How to know the job is done"],"text":["<div class=\"sect1\"> <h2 id=\"_component_runtime_junit\"><a class=\"anchor\" href=\"#_component_runtime_junit\"></a>component-runtime-junit</h2> <div class=\"sectionbody\"> <div class=\"paragraph\"> <p><code>component-runtime-junit</code> is a small test library allowing you to validate simple logic based on Talend Component tooling.</p> </div> <div class=\"paragraph\"> <p>To import it add to your project the following dependency:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><dependency> <groupId>org.talend.sdk.component</groupId> <artifactId>component-runtime-junit</artifactId> <version>${talend-component.version}</version> <scope>test</scope> </dependency></code></pre> </div> </div> <div class=\"paragraph\"> <p>This dependency also provide some mocked components that you can use with your own component to create tests.</p> </div> <div class=\"paragraph\"> <p>The mocked components are provided under the family <code>test</code> :</p> </div> <div class=\"ulist\"> <ul> <li> <p><code>emitter</code> : a mock of an input component</p> </li> <li> <p><code>collector</code> : a mock of an output component</p> </li> </ul> </div> <div class=\"sect2\"> <h3 id=\"_junit_4\"><a class=\"anchor\" href=\"#_junit_4\"></a>JUnit 4</h3> <div class=\"paragraph\"> <p>Then you can define a standard JUnit test and use the <code>SimpleComponentRule</code> rule:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\">public class MyComponentTest {","final Map<String, String> configuration = configurationByExample(componentConfig);</code></pre> </div> </div> <div class=\"paragraph\"> <p>The same factory provides a fluent DSL to create configuration calling <code>configurationByExample</code> without any parameter. The advantage is to be able to convert an object as a <code>Map<String, String></code> as seen previously or as a query string to use it with the <code>Job</code> DSL:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\">final String uri = \"family://component?\" configurationByExample().forInstance(componentConfig).configured().toQueryString();</code></pre> </div> </div> <div class=\"paragraph\"> <p>It handles the encoding of the URI to ensure it is correctly done.</p> </div> </div> <div class=\"sect2\"> <h3 id=\"_testing_a_mapper\"><a class=\"anchor\" href=\"#_testing_a_mapper\"></a>Testing a Mapper</h3> <div class=\"paragraph\"> <p>The <code>SimpleComponentRule</code> also allows to test a mapper unitarly, you can get an instance from a configuration and you can execute this instance to collect the output. Here is a snippet doing that:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\">public class MapperTest {","The folowing artifact will allow you to test against a spark cluster:","The usage relies on a JUnit TestRule. It is recommanded to use it as a @ClassRule to ensure a single instance of a spark cluster is built but you can also use it as a simple @Rule which means it will be created per method instead of per test class.","It takes as parameter the spark and scala version to use. It will then fork a master and N slaves. Finally it will give you submit* method allowing you to send jobs either from the test classpath or from a shade if you run it as an integration test.","Here is a sample:","this is working with @Parameterized so you can submit a bunch of jobs with different args and even combine it with beam TestPipeline if you make it transient!","The integration with JUnit 5 of that spark cluster logic uses @WithSpark marker for the extension and let you, optionally, inject through @SparkInject, the BaseSpark<?> handler to access te spark cluster meta information - like its host/port.","Here is a basic test using it:","In current state, SparkClusterRule doesn’t allow to know a job execution is done - even if it exposes the webui url so you can poll it to check. The best at the moment is to ensure the output of your job exists and contains the right value.","awaitability or equivalent library can help you to write such logic.","Here are the coordinates of the artifact:","And here is how to wait a file exists and its content (for instance) is the expected one:","<div class=\"sect1\"> <h2 id=\"component_runtime_http_junit\"><a class=\"anchor\" href=\"#_component_runtime_http_junit\"></a>component-runtime-http-junit</h2> <div class=\"sectionbody\"> <div class=\"paragraph\"> <p>The HTTP JUnit module allows you to mock REST API very easily. Here are its coordinates:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-xml hljs\" data-lang=\"xml\"><dependency> <groupId>org.talend.sdk.component</groupId> <artifactId>component-runtime-junit</artifactId> <version>${talend-component.version}</version> <scope>test</scope> </dependency></code></pre> </div> </div> <div class=\"admonitionblock tip\"> <table> <tr> <td class=\"icon\"> <i class=\"fa icon-tip\" title=\"Tip\"></i> </td> <td class=\"content\"> this module uses Apache Johnzon and Netty, if you have any conflict (in particular with netty) you can add the classifier <code>shaded</code> to the dependency and the two dependencies are shaded avoiding the conflicts with your component. </td> </tr> </table> </div> <div class=\"paragraph\"> <p>It supports JUnit 4 and JUnit 5 as well but the overall concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.</p> </div> <div class=\"paragraph\"> <p>You can plug your own <code>ResponseLocator</code> to map a request to a response but the default implementation - which should be sufficient in most cases - will look in <code>talend/testing/http/<class name><method name>.json</code>. Note that you can also put it in <code>talend/testing/http/<request path>.json</code>.</p> </div> <div class=\"sect2\"> <h3 id=\"_junit_4\"><a class=\"anchor\" href=\"#_junit_4\"></a>JUnit 4</h3> <div class=\"paragraph\"> <p>JUnit 4 setup is done through two rules: <code>JUnit4HttpApi</code> which is responsible to start the server and <code>JUnit4HttpApiPerMethodConfigurator</code> which is responsible to configure the server per test and also handle the capture mode (see later).</p> </div> <div class=\"admonitionblock important\"> <table> <tr> <td class=\"icon\"> <i class=\"fa icon-important\" title=\"Important\"></i> </td> <td class=\"content\"> if you don’t use the <code>JUnit4HttpApiPerMethodConfigurator</code>, the capture feature will be deactivated and the per test mocking will not be available. </td> </tr> </table> </div> <div class=\"paragraph\"> <p>Most of the test will look like:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\">public class MyRESTApiTest { @ClassRule public static final JUnit4HttpApi API = new JUnit4HttpApi();","@Test public void test() throws Exception { final HttpsURLConnection connection = getHttpsConnection(); connection.setSSLSocketFactory(API.getSslContext().getSocketFactory()); // …. }</code></pre> </div> </div> </div> </div> <div class=\"sect2\"> <h3 id=\"_junit_5\"><a class=\"anchor\" href=\"#_junit_5\"></a>JUnit 5</h3> <div class=\"paragraph\"> <p>JUnit 5 uses a JUnit 5 extension based on the <code>HttpApi</code> annotation you can put on your test class. You can inject the test handler (which has some utilities for advanced cases) through <code>@HttpApiInject</code>:</p> </div> <div class=\"listingblock\"> <div class=\"content\"> <pre class=\"highlightjs highlight\"><code class=\"language-java hljs\" data-lang=\"java\">@HttpApi class JUnit5HttpApiTest { @HttpApiInject private HttpApiHandler<?> handler;"]}]